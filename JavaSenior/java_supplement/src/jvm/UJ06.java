package jvm;

/**
 * 【对象的内存分配流程】见xmind
 *  当我们new一个对象，开始流程。（1）大部分对象的内存 是在堆上分配的，只有小部分是在栈上分配的。根据 逃逸分析 算法进行判断，决定是否在栈上分配，栈上分配后的对象通过标量分析，会被拆分成更小的部分
 *   （2）如果不允许被栈上分配，就会在堆上进行分配，如果被判定为java中的大对象，该对象会直接在老年代中被进行分配
 *   （3）若并未判定为大对象，对象会通过 线程本地分配缓冲区TLAB进行判断后，在eden区完成内存分配
 *  逃逸分析：原则（1）当对象的 适用范围不止当前方法，那么不允许对象在栈上分配。
 *                 （2）当对象 只在当前方法中使用，那么允许对象在栈上分配
 *     如下的get()与save方法
 *  当经过了逃逸分析后的对象，若对象在栈上进行分配，jvm会通过标量替换来拆解对象
 *     如下的student对象中，首先拆解出name属性，然后对Teacher对象也采取同样的手段。。
 *
 * 【内存划分方式】
 * （1）指针碰撞：将内存拆分，中间放一个指针，指针左边是已分配的内存空间，右边是空闲的内存空间。
 *     申请内存时，将空间内存空间中的内存划出，指针向右移动
 *  缺点：无法分配 非连续的内存空间
 * （2）空闲列表：空闲列表记录了哪段内存地址是空闲的，申请内存空间时，从这个空闲列表中的区域获取内存地址
 *
 *  【内存分配并发问题 的解决方案】
 *  在创建对象的时候有一个很重要的问题，就是线程安全。作为虚拟机来说，通常有两种方式来保证线程安全：
 *  （1）CAS+失败重试: compareAndSwap
 *      CAS 加 失败重试机制 来保证更新原子性，从而解决并发问题。
 *      CAS是乐观锁的一种实现方式。即每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。
 *  （2）TLAB：本地线程分配缓冲区
 *      每个线程在创建时，这个线程为自己提前申请一小块的内存空间！
 *      结合对象的内存分配流程：
 *      TLAB的判断指的是，先判断TLAB中的内存空间是否足够可用，如果足够可用，则在该内存中进行分配，此时不会产生并发问题（因为线程是私有的，申请的内存空间也是私有不可重复的）
 *      当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配
 *
 * 【java的四大引用类型】
 * JDK1.2 后对引用进行了扩充，将引用分为强引用（Strongly Re-ference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）4种，这4种引用强度依次逐渐减弱。
 * （1）强引用：强引用是最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“Object obj = new Object()”这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。
 * （2）软引用：软引用是用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。在JDK 1.2版之后提供了SoftReference类来实现软引用
 *      ** 软引用用来缓存服务器中间计算结果及不需要实时保存的用户行为等（备用和缓存）**
 * （3）弱引用：弱于软引用，弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK 1.2版之后提供了WeakReference类来实现弱引用。**弱引用常用于ThreadLocal中，用来保证上下文同一个对象**
 * （4）虚引用：虚引用也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。定义完成后无法通过该引用获取对象。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时受到一个系统通知。在JDK 1.2版之后提供了PhantomReference类来实现虚引用。
 *      常用于管理堆外内存
 *
 @author Alex
 @create 2023-06-10-15:14
 */
public class UJ06 {
    // 当对象的 适用范围不止当前方法，那么不允许对象在栈上分配
    public Student get() {
        Student student = new Student();
        student.setName("廖泽宇");
        return student;
    }

    // 当对象 只在当前方法中使用，那么允许对象在栈上分配
    public void save() {
        Student student = new Student();
        student.setName("廖泽宇");
    }
}

class Student {
    private String name;
    private Teacher teacher;

    public void setName(String name) {
        this.name = name;
    }

    public void setTeacher(Teacher teacher) {
        this.teacher = teacher;
    }
}

class Teacher {
    private String name;
}