package mutilThread;

/**
 * 【缓存行cacheline】
 *  CPU读取内存中的数据的过程：见xmind
 *   CPU到内存之间有L1，L2，L3多层缓存（L1L2为私有缓存，常位于cpu上，L3为公共缓存，常位于主板上多个cpu访问相同的L3）。
 *   当需要读取数据时，CPU会先从最近的缓存L1中寻找，一直逐层读取到主内存main memory
 *   若直到 找到主内存中存在需要的数组X，则先将其存到缓存L3 ==> L2 ==> L1，最后由CPU开始计算
 *   ✔实际上，我们从内存往缓存中读数据是按"块"读（因为程序往往有一个局部性原理，当使用某一个数据后，很可能接下来会使用其相邻的数据）
 *   ✔这个"块"的概念，专业术语上称 cacheline缓存行，一个缓存行占64字节
 *    缓存行的这种特性也决定了在访问同一缓存行中的数据时效率是比较高的。比如当你访问java中的一个long类型（8字节）的数组，当数组中的一个值被加载到缓存中，它会额外加载另外7个，因此可以非常快速的遍历这个数组（遍历连续的内存块中分配的数据结构非常快速）
 *
 * 【系统底层如何实现数据一致性】并发编程的三大特性之可见性/一致性（可见性、有序性、原子性）
 *  java层面：除了volatile外，synchronized和final也可以保证可见性
 *  jvm层面：如果对声明了 volatile 变量将进行写操作，JVM就会向处理器发送一条Lock前缀的指令，将这个变量所在的缓存行的数据立即写回到系统内存。并且cpu读取volatile标识的变量时 只能从系统内存中读取，不能从缓存中读取。这样便保证了线程的可见性。
 *  cpu层面：数据一致性即指的是，当某一颗cpu改变了某个缓存行中的一个值✔，通知所有其他拥有该缓存行的cpu，该缓存行失效，请从内存中重新读取数据
 *   即在cpu级别的数据一致性，是以缓存行为单位的。。实现方式是通过缓存一致性协议（MESI）做到的
 *   MESI做不到的可以用锁总线的方式实现（只允许当前cpu访问）
 *  MESI：其中一种缓存一致性协议。 MESI是intel芯片的协议，不同的公司缓存一致性协议名称不同
 *    cpu将缓存行标记为了四种状态，Modified,Exclusive,Shared,Invalid
 *     缓存一致性协议即当cpu修改某一缓存行的数据时，将当前缓存行修改为modified，然后通知所有其他拥有该缓存行的cpu，将该缓存标记为invalid
 *     若cpu需要修改缓存行状态为invalid中的数据时，需要从内存中重新读取数据到缓存中
 *  缓存一致性协议是硬件级别的协议，不受软件控制，和java层面的volatile有天壤之别
 *
 * 【伪共享问题】
 *  举例（见xmind多核cpu缓存结构图）：
 *   在core1上线程需要更新变量X, 同时core2上线程需要更新变量Y，X和Y处于同一个缓存行。。。。在这种情况下，每个线程都要去竞争缓存行的所有权来更新对应的变量。
 *   如果core1获得了缓存行的所有权，那么缓存子系统将会使core2中对应的缓存失效。
 *   相反，如果core2获得了所有权然后执行更新操作，core1就要使自己对应的缓存行失效。
 *   这里需要注意：整个操作过程是以缓存行为单位进行处理的，这会来来回回的经过L3缓存，大大影响了性能，
 *   core1和core2的修改本应该是一个并行的操作，但是由于缓存一致性协议，却成为了串行！这就是伪共享问题，即每次当前线程对缓存行进行写操作时，内核都要把另一个内核上的缓存块无效掉，并重新读取里面的数据。
 *
 * 【缓存行对齐】
 *  缓存行对齐是一种编程技巧。。。在一些会频繁操作数据的情况下，若不希望出现伪共享问题 ~，可以根据缓存行的特性进行缓存行对齐，即将要操作的数据凑齐一个缓存行进行操作
---------------------
private static class Padding{
    public volatile long p1,p2,p3,p4,p5,p6,p7;  // 7*8字节
}

public static class T extends Padding{
    private volatile long x = 0L;  // 此时一个T就占了64字节，占满了一个缓存行
}

private static T[] arr = new T[2];

static {
    arr[0] = new T();  // 此时arr[0]和arr[1]必然处在不同的缓存行，不同的缓存行直接
    arr[1] = new T();
｝
---------------------
 *  若数据本身就超过了缓存行的大小，此时仍希望保持数据一致性，只能通过锁总线的方式（即当前cpu访问时，不允许其他的cpu访问）
 *
 * 【乱序执行】
 *  指令乱序执行主要由两种因素导致：（1）编译期指令重排。（2）运行期 CPU 乱序执行。
 *  无论是编译期的指令重排还是 CPU 的乱序执行，主要都是为了让 CPU 内部的指令流水线可以“充满”，提高指令执行的并行度。
 *   （允许重排序的原则：单线程下 两条无关的 最终能导致相同结果的指令，可以乱序执行）
 *  as-if-serial：了解。该原则规定了 不管怎么重排序，单线程程序的执行结果不能改变，编译器和处理器必须遵循 as-if-serial 语义。
 *                 为了遵循 as-if-serial，编译器和处理器不会对存在数据依赖关系的操作重排序，因为这种重排序会改变执行结果。
 *                 但是如果操作之间不存在数据依赖关系，这些操作就可能被编译器和处理器重排序。
 *
 @author Alex
 @create 2023-06-25-13:11
 */
public class UM03 {

}
