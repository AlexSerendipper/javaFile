package mutilThread;

/**
 * 【锁】
 *  Java锁用于控制多个线程对共享资源的并发访问。Java锁的作用是保证线程间的互斥性, 即同一时刻只有一个线程可以访问共享资源,从而避免多线程间的竞态条件和其他并发问题
 *  不持有锁的线程会怎样：
 *  （1）忙等待，即自旋等待，也即轻量级锁。有人释放了锁，都上去抢锁，谁抢到谁进入
 *  （2）等待队列，即重量级锁。进入队列后，将交由操作系统进行调度！由操作系统决定何时能进入
 *
 * 【CAS】compare and swap自旋锁，属于乐观锁的一种实现
 *  可以在没有锁的情况下，对数值进行更新操作 且 不会产生并发问题（保证线程一致性）
 *  工作流程（原理）
 * （1）首先读取当前值 并存入E，然后进行更新操作，将结果存入V
 * （2）再次读取当前值 并存入N
 *      若 E=N，则代表修改过程中没有其他线程进行更新操作，直接对数据进行更新即可
 *      若 E≠N，则代表修改过程中有其他线程进行更新操作，则回到(1)，即重新 首次读取当前值
 *  ABA问题
 *   ✔E=N，但是实际上过程中有其他线程进行更新操作，只不过是多次更新后最后值与原值相同
 *  ABA问题解决
 *   可以通过添加版本号的方式解决ABA问题。
 *   如第一次读取的E=0，版本号为1.0。第二次读取时N=0，版本号为2.0，即说明了版本被更新过
 *   （当然也可以使用布尔类型进行标记，修改过版本号为true~）
 *
 * 【锁升级过程】把不同的对象当锁，实际上就是修改该对象markword上记录
 *  偏向锁（new对象时） ==> 轻量级锁（无锁、自旋锁、自适应自旋） ==>重量级锁
 *  不同锁状态下，markword的布局
 * （1）new对象：刚new的对象，未加锁的状态下，若调用了hashcode()，会将该实体的31位的hashcode存入
 *              4位用来存储分代年龄，所以最多存15代
 *              3位/2位用来存储 锁信息
 * （2）偏向锁：当可能存在多个线程（synchronized），并且竞争不是特别激烈时，没有必要申请排他锁（工业生产中的代码，80%都是单线程，让当前线程工作完后 让给下一个线程就好了）
 *              偏向锁的想法类似于贴标签，使用52位来记录了一个指向当前线程的指针。
 * （3）轻量级锁（乐观锁）：当另一个线程与持有偏向锁的线程发生任意的竞争，就会撤销偏向锁，自动升级为轻量级锁
 *               此时，每个线程都会在各自的线程栈中生成自己的lock record对象。
 *               撤销偏向锁后，各个线程使用自旋（CAS）的方式✔ 去竞争轻量级锁
 *               得到轻量级锁的线程，使用62位来记录 指向当前线程中lock record的指针
 * （4）重量级锁（排他锁）：早期jdk在 某线程自旋超过了10次，或者等待自旋的线程超过了整个cpu核数的二分之一，即竞争特别激烈。锁升级为重量级锁
 *                        (wait()方法会直接升级，进入队列)
 *                         jdk升级到某个版本(1.6)之后，变成了自适应调优，自动判定何时升级为重量级锁
 *                         重量级锁需要向内核态中申请（其他锁在用户态即可申请），并且重量级锁是mutex结构，在内核态中也是有数量限制的
 *                         申请到重量级锁的线程进入等待队列（重量级锁维护了一个队列），由操作系统进行调度，指挥执行队列中下一个线程
 *
 * 【synchronized 的底层实现原理】包含了锁升级过程
 * （1）java代码层级：添加synchronized关键字
 * （2）字节码层级：synchronized 被翻译为 monitorenter moniterexit
 * （3）jvm：执行过程中，自动进行锁升级
 * （4）hotSpot层面：
 *              问：多核cpu进行CAS锁升级时，是如何保证原子性的？
 *              答：调用lock comxchg（汇编语言，compare and exchange），
 *              使用comxchg指令，即底层cpu支持CAS操作，但是该操作是非原子性的
 *              使用lock指令，底层具体是调用 cpu锁定缓存行 或者 锁总线来实现的，可以保证了一个cpu执行时不会被另一颗cpu打断，保证了原子性！！！
 *  注意：synchronized加锁的代码中，指令仍然能够重排序，即synchronized能够保证程序的可见性(CAS)和原子性(lock)，无法保证其有序性
 *
 *  【重入锁】
 *  java中大多数的锁都是重入锁，即可以在一个 锁的内部继续加锁（同一把锁）。。。如synchronized,lock锁等。。。。
 *  实际上 锁可重入 是非常常用的，譬如 子类重写父类的 一个同步方法 synchronized m()，并在该方法中调用了父类的 synchronized m()方法，此即为锁重入
 *   重入锁解决了 连续多次对同一把锁进行lock时，会造成死锁的问题。
 *   重入锁使同一个线程可以对同一把锁在不释放的前提下，反复的加锁不会导致线程的卡死，唯一的一点就是需要保证 unlock() 的次数和 lock()一样的多。
--------------
synchronized m(Object o1){
   super.synchronized(Object o1){

   }
}
--------------
 @author Alex
 @create 2023-06-21-14:39
 */
public class UM02 {
}
