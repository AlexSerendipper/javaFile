package jvm;

/**
 * 【常见的GC算法】
 * （1）标记清除法
 * （2）标记压缩
 * （3）复制算法
 * （4）引用计数法
 *
 * 【GC】Garbage Collection：垃圾收集
 *  Java中,GC的对象是Java堆和方法区(的永久区里)
 *  JVM在进行GC时，并不是对 新生区、老年区 进行统一的回收
 *   绝大部分时候都是对新生区（包含幸存区）进行回收
 *
 * 【常见GC算法1】jvm如何 在回收前如何判断对象已死
 * （0）引用计数算法(reference counting)
 *  引用计数算法是最容易实现的，现代编程语言比如Lisp，Python，Ruby等的垃圾收集算法采用的就是引用计数算法。
 *  原理:实际上是通过在对象头中分配一个空间来保存该对象被引用的次数。如果该对象被其它对象引用，则它的引用计数+1，如果删除对该对象的引用，那么它的引用计数就-1，
 *      当该对象的引用计数为0时，那么该对象就会被回收。
 *  缺点：引用计数法无法解决循环引用的问题（Object 1和Object 2其实都可以被回收，但是它们之间还有相互引用，所以它们各自的计数器为1，则还是不会被回收），
 *         并且 计数器其本身也会带来的固有消耗！，✔目前JVM中几乎不会使用这个算法
 * （1）可达性分析
 *  Java虚拟机没有采用引用计数法。它采用的是可达性分析算法。可达性分析算法的思路就是通过一系列的“GC Roots”，也就是根对象作为起始节点集合，
 *   从根节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为引用链，如果某个对象到GC Roots间没有任何引用链相连。
 *
 * 【常见GC算法2】
 * （2）复制算法
 *  ✔JVM年轻代 中，基本上都是使用这个算法
 *  复制算法可以保证to区永远是干净的
 *   每一次GC后，都会将Eden区中存活下来的对象移动到幸存区中（eden区被清空）。
 *   第一次移动，移动到哪个区，哪个区就是from，即剩下的空的区为to。。。为了方便理解，可以用口诀 "谁空谁是to" 来记忆
 *   第二次以及之后的GC，存活下来的对象到to区中区，此时from和to两个区都有对象，此时将其中一个区的对象移动到另一个区（通常将from移动到to），腾出的空区为to区
 *  默认当一个对象经历了15次GC 都还没有被清除，就会进入老年区
 *     -XX: MaxTenuringThreshold=15                  # 设置几次GC后进入老年区
 *  优点：运行高效，没有内存碎片（对象都规整到from区，保证了to区永远干净）
 *   缺点: 浪费了内存空间（to区永远为空）
 *  问题：如果eden区空间很大，并且其所有对象都幸存下来了，在from和to区进行复制的消耗是很大的
 *    所以复制算法最佳使用场景是在对象存货度较低的区域，即在新生代中能得到很好的利用
 *
 * （3）标记清除算法：见xmind
 *  ✔目前JVM老年代中，基本都是使用标记整理算法，标记清除算法就是标记整理算法的前身（当JVM产生的内存碎片不多时，就使用标记清除算法）
 *  标记-清除算法将垃圾回收分为两个阶段：标记阶段和清除阶段。
 *   在标记阶段，标记所有 活动的对象（从每个 GC Roots 出发依次标记有引用关系的对象）
 *   在清除阶段，清除所有未被标记的对象。
 *  优点：不需要额外的空间（复制算法就需要两块空间）
 *   缺点：两次扫描严重浪费时间,并且还会产生内存碎片
 *
 *（4）标记 压缩/整理算法(老年代)
 *  标记-压缩算法适合用于存活对象较多的场合，如老年代。
 *   它在标记-清除算法的基础上做了一些优化。
 *   即在清除阶段，它并不简单的清理未标记的对象，而是将所有的存活对象压缩到内存的一端，然后清理边界外所有的空间以便复用，由此来解决内存碎片的问题！
 *  优点：解决了内存碎片问题
 *   缺点：多了一个移动的成本
 *
 *（5）总结
 * 内存效率(时间复杂度):复制算法>标记清除算法>标记压缩算法
 * 内存整齐度:复制算法=标记压缩算法>标记清除算法
 * 内存利用率:标记压缩算法=标记清除算法>复制算法
 *
 *（6）分代-收集算法
 *  分代收集算法是现在普遍采用的垃圾收集算法：
 *    把堆内存分为新生代和老年代。新生代采用复制算法，老年代采用标记清除和标记整理的算法
 *  JVM调优很多就是在调整 标记清除和整理 的次数，如几次标记清除后进行整理
 *
 * 【什么情况下对象会进入老年代？】
 * （1）躲过15次GC之后会进入老年代
 * （2）大对象直接进入老年代
 *     大对象是指需要大量连续内存空间的Java对象，比如很长的字符串或者是很大的数组或者 List集合，大对象在分配空间时，容易导致内存明明还有不少空间时就提前触发垃圾回收以获得足够的连续空间来存放它们，而当复制对象时，大对象又会引起高额的内存复制开销，为了避免新生代里出现那些大对象，然后屡次躲过GC而进行来回复制，此时JVM 就直接把该大对象放入老年代，而不会经过新生代。
 * （3）动态年龄判断
 *    Survivor区的对象年龄从小到大累加，当累加到X年龄时占用空间的总和大于50%，则比X年龄大的对象都要晋升到老年代。
 * （4）JVM的空间担保机制(避免频繁进行Full GC)
 *    新生代Minor GC后剩余存活对象太多，无法放入S区，就必须把这些存活对象转移到老年代中，如果此时老年代空间也不够怎么办？
 *    每次执行Minor GC之前，JVM会检查一下老年代可用的内存空间，是否大于新生代所有对象的总大小。（在极端情况下，新生代Minor GC之后，所有对象都需要存活，造成新生代所有对象都要进入老年代）
 *    如果老年代可用内存大于新生代所有对象总大小，就可以大胆发起Minor GC，因为即使所有新生代对象都存活，S区放不下，也可以转到老年代中。
 *    如果老年代可用空间小于新生代所有对象总大小，那么就去判断老年代可用空间大小是否大于之前每一次Minor GC后进入老年代的对象的平均大小。
 *       - 如果小于就会直接触发FullGC
 *       - 如果大于，就可以冒险尝试Minor GC。但是有可能会出现新生代存活对象大小大于S空间同时也大于老年代可用空间，此时就会触发“Full GC”。如果Full GC后，老年代还是没有足够的空间来存放Minor GC后的剩余存活对象，那么就会导致内存溢出。
 @author Alex
 @create 2023-06-09-14:16
 */
public class UJ04 {
}
