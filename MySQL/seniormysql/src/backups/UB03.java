package backups;

/**
 * 【主从复制】
 *  在数据库优化中我们学到过，提高数据库并发能力有两种方式
 * （1）redis:
 *    在实际工作中，我们常常将 Redis 作为缓存与 MySQL 配合来使用，当有请求的时候，首先会从缓存中进行查找，如果存在就直接取出。
 *    如果不存在再访问数据库，这样就提升了读取的效率，也减少了对后端数据库的 访问压力 。Redis的缓存架构是 高并发架构 中非常重要的一环。
 * （2）主从复制:
 *
 * 【主从复制的优点】
 *  主从同步设计不仅可以提高数据库的吞吐量，还有以下 3 个方面的作用。
 * （1）读写分离： 我们可以通过主从复制的方式来 同步数据 ，然后通过读写分离提高数据库并发处理能力。
 *                具体原因是，其中一个是Master主库，负责写入数据，我们称之为：写库。其它都是Slave从库，负责读取数据，我们称之为：读库。
 *                当主库进行更新的时候，会自动将数据复制到从库中，而我们在客户端读取数据的时候，会从从库中进行读取。
 *                面对“读多写少"的需求，采用读写分离的方式，可以实现 更高的并发访问。
 *                同时，我们还能对 从服务器 进行负载均衡，让不同的读请求按照策略均匀地分发到不同的从服务器上，让 读取更加顺畅。
 *                读取顺畅的另一个原因，就是 减少了锁表的影响，比如我们让主库负责写，当主库出现写锁的时候，不会影响到从库进行SELECT的读取。
 * （2）数据备份：热备份机制，也就是在主库正常运行的情况下进行的备份，不会影响到服务。
 * （3）高可用性：当服务器出现 故障 或 宕机 的情况下，可以 切换 到从服务器上，保证服务的正常运行。
 *
 * 【主从复制原理】
 *  三个线程：主从复制过程中，会基于3个线程来操作，一个主库线程，两个从库线程。
 *    主库线程1：二进制日志转储线程，主库将二进制日志发送给从库
 *    从库线程1：从库 I/O 线程，读取到主库的二进制日志转储线程发送的 Binlog 更新部分，并且拷贝到本地的中继日志 （Relay log）。
 *    从库线程2：从库 SQL 线程，读取从库中的中继日志，并且执行日志中的事件，将从库中的数据与主库保持同步。
 *  主从复制步骤
 *    步骤1：Master将写操作记录到二进制日志（binlog）。这些记录叫做 二进制日志事件(binary log events);
 *    步骤2：Slave将Master的binary log events拷贝到它的中继日志（relay log）；
 *    步骤3：Slave重做中继日志中的事件，将改变应用到自己的数据库中。 MySQL复制是异步的且串行化的，而且重启后从接入点开始复制。
 *  主从复制的问题：延时（Master更新 到 slave更新之间的时间延迟）
 *  主从复制的基本原则
 *    每个Slave只有一个Master
 *    每个Slave只能有一个唯一的服务器ID
 *    每个Master可以有多个Slave
 *
 * 【主从复制实现】 P192中，在Linux中实现了一主一从的主从同步。但我感觉暂时用不到具体如何配置，以后有需要在学吧..
 *  binlog格式设置：
 *  （1）STATEMENT模式 （基于SQL语句的复制(statement-based replication, SBR)）
 *      binlog日志中记录 每一条修改数据的sql语句。这是默认的binlog格式。
 *      优点：binlog日志量小、
 *           可以用于实时的还原，而不仅仅用于复制、
 *           主从版本可以不一样，从服务器版本可以比主服务器版本高
 *      缺点：不是所有的UPDATE语句都能被复制，尤其是包含不确定操作的时候（如UUID(),DATE()等语句）
 *            复制需要进行全表扫描(WHERE 语句中没有使用到索引)的 UPDATE 时，需要比 RBR 请求更多的行级锁
 *  （2）ROW模式（基于行的复制(row-based replication, RBR)）
 *      binlog日志中记录 哪条数据被修改了，修改成什么样了。
 *      优点：所有的UPDATE语句都能被复制
 *           执行 INSERT，UPDATE，DELETE 语句时锁更少
 *           从服务器上采用 多线程 来执行复制成为可能
 *      缺点：binlog日志量大
 *           无法从 binlog 中看到都复制了什么语句
 *  （2）MIXED模式（混合模式复制(mixed-based replication, MBR)）
 *      MIXED模式是Statement与Row的结合。
 *      在Mixed模式下，一般的语句修改使用statment格式保存binlog。如一些函数，statement无法完成主从复制的操作，则采用row格式保存binlog。
 *
 * 【主从复制的延迟问题】
 *  日志从主库传给从库，从库接收完binlog 到 执行完这个事务。。这个过程所花费的时间即为主从复制的延迟
 *  如何降低 主从延迟的时间
 *   （1）降低多线程大事务并发的概率，优化业务逻辑
 *   （2）优化SQL，避免慢SQL，减少批量操作，建议写脚本以update-sleep这样的形式完成。
 *   （3）提高从库机器的配置，减少主库写binlog和从库读binlog的效率差。
 *   （4）尽量采用短的链路，也就是主库和从库服务器的距离尽量要短，提升端口带宽，减少binlog传输的网络延时。
 *   （5）实时性要求的业务读强制走主库，从库只做灾备，备份。
 *
 * 【主从复制的一致性问题】
 *  主从同步的要求：
 *    读库和写库的数据一致(最终一致)；
 *    写数据必须写到写库；
 *    读数据必须到读库(不一定)；
 *  解决主从之间 数据复制方式 问题，按照数据一致性 从弱到强 来进行划分，有以下 3 种复制方式。
 * （1）异步复制
 * 异步模式就是客户端提交COMMIT之后不需要等从库返回任何结果，而是直接将结果返回给客户端（即告诉客户可以直接进行查询了），
 * 这样做的好处是不会影响主库写的效率，但可能会存在主库宕机，而Binlog还没有同步到从库的情况，也就是此时的主库和从库数据不一致。
 * 这时候从从库中选择一个作为新主（新的master），那么新主则可能缺少原来主服务器中已提交的事务。所以，这种复制模式下的数据一致性是最弱的。
 * （2）半同步复制✔✔✔解决主从复制一致性的问题
 * 原理是在客户端提交COMMIT之后不直接将结果返回给客户端，而是等待至少有一个从库接收到了Binlog，并且写入到中继日志中，再返回给客户端。
 * 这样做的好处就是提高了数据的一致性，但是相比于异步复制来说，至少多增加了一个网络连接的延迟，降低了主库写的效率。
 * 在MySQL5.7版本中 增加了一个rpl_semi_sync_master_wait_for_slave_count参数，可以对应答的从库数量进行设置，默认为1，也就是说只要有1个从库进行了响应，就可以返回给客户端。
 * 如果将这个参数调大,可以提升数据一致性的强度，但也会增加主库等待从库响应的时间。
 *
 * 强一致性意味着在分布式系统中的所有副本上，任何数据的更新对所有副本读操作可见，即要求所有节点都保持数据同步。。因此半同步复制是相比于异步复制更加接近强一致性
 * （3）组复制：了解即可
 * 异步复制和半同步复制都无法最终保证数据的一致性问题，半同步复制是通过判断从库响应的个数来决定是否返回给客户端，虽然数据一致性相比于异步复制有提升，但仍然无法满足对数据一致性要求高的场景，比如金融领域。
 * MGR 很好地弥补了这两种复制模式的不足。
 * 组复制技术，简称 MGR（MySQL Group Replication）。是 MySQL 在 5.7.17 版本中推出的一种新的数据复制技术，这种复制技术是基于 Paxos 协议的状态机复制。
 *
 *
 @author Alex
 @create 2023-05-28-14:44
 */
public class UB03 {
}
