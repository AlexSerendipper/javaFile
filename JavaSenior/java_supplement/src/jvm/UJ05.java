package jvm;

/**
 * 【JMM】java memory mode, java的内存模型
 *  JMM的定义：是一个缓存一致性的协议，用于定义数据读写的规则。
 *             是一种抽象的概念，描述了一组规则或规范
 *  JMM的作用：JMM定义了线程 工作内存和主内存之间的抽象关系，
 *             从而确定了哪些操作是线程安全的，哪些操作是线程不安全的
 *             具体的如：线程之间的共享变量存储在主内存中（main memory），每个线程都有自己的私有本地内存（local memory）
 *  共享对象的 可见性/一致性 问题：
 *   解决主内存和私有本地内存中数据的一致性问题，可以使用 volilate关键字，该关键字可以将本地内存中的修改立刻更新到主内存中
 *
 * 【JMM的规则】定义的数据读写的规则
 * (1) 不允许read和load、store和write操作之一 单独出现，即使用了read必须load，使用了store必须write
 * (2) 不允许一个线程丢弃它最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。
 * (3) 不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存中。
 *     前面三点就是 volilate 关键字所实现的功能了
 * (4) 一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。
 *     这也很合理，因为new操作都是在堆中，在主内存中，工作内存是线程从 主内存中拷贝出来的
 * (5)一个变量在同一个时刻只允许一条线程对其进行lock操作
 *     这个实际上就是lock锁，高并发状态下，只能允许一个线程拿到锁
 * (6) 如果对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作以初始化变量的值。
 * (7) 如果一个变量事先没有被lock操作锁定，那就不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定的变量。
 * (8) 对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）
 *
 @author Alex
 @create 2023-06-09-16:14
 */
public class UJ05 {
}
