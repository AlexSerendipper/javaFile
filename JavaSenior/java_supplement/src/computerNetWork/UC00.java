package computerNetWork;

/**
 * 【IO模型】在高并发情况下，服务端如何处理客户端连接及数据发送！
 *  举例说明各种IO模型，实际也是进化的过程**(同步阻塞==>同步非阻塞==>select/poll==>epoll):
 *   你是一个老师，让学生做作业，学生做完作业后收作业。
 *（1）同步阻塞IO（BIO模型）:
 *     解释1：逐个收作业，先收A,再收B,接着是C、D,如果有一个学生还未做完，则你会等到他写完，然后才继续收下一个。
 *     解释2✔：如图，在服务端完成socket初始化后，调用accept方法等待客户端建立连接（阻塞等待），客户端服务端三次握手建立连接后，继续等待客户端发送数据（阻塞等待），直到处理完客户端1的请求后才去处理客户端2
 *  缺点：
 *     单线程：若某个socket阻塞，会影响到其他socket的处理
 *     多线程：即若为每个连接都分配一个线程来进行管理，若出现特殊的情况，socket在不同的时间内就绪。实际上只需要单线程就可以处理，这种情况下会造成资源的浪费。
 *               并且，线程的调度、上下文切换乃至它们占用的内存，可能都会成为瓶颈。
 *
 *
 *（2）同步非阻塞IO:
 *     解释1：逐个收作业，先收A,再收B,接着是C、D,如果有一个学生还未做完,则你会跳过该学生，继续去收下一个。
 *     解释2✔： 服务端不断的检查是否客户端有发起连接（接收到的fd是否为非负整数），如果客户端没有发起连接，返回的fd就是一个负数，直到轮巡到有正常数据到来的fd
 *     解释3：从操作系统的底层来看，目前的linux操作系统底层分为用户空间（用户态）和内核空间（内核态），在用户空间下执行一些安全的用户指令，在内核空间中执行一些特权指令。
 *             `socket的操作是需要在内核空间中完成的，但是内核将socket调用的能力的封装成了系统调用函数（read,write）供用户空间使用。
 *             在用户空间调用系统调用函数，由内核空间执行，并将结果返回用户空间`。。。。。
 *             `read函数`：数据从网卡拷贝到内核空间，再从内核空间拷贝到用户空间。
 *             `write函数`：数据从用户空间拷贝到内核空间，再从内核空间拷贝到网卡上，
 *             当用户调用read/write函数时，如果没有就绪的数据，非阻塞IO会马上返回非法fd，然后主线程继续查看下一个连接，而不是像阻塞IO一样阻塞住。
 *  优点：单个socket不会影响到其他socket
 *  缺点：需要不断的遍历进行系统调用(read)来检查数据是否到来，这个系统调用涉及到用户态和内核态的转换，当socket比较多的时候，这会是一笔很大的开销。
 *
 *（3） IO多路复用模型: 主要能解决同步非阻塞IO下系统调用频繁的问题
 *     解释1：学生写完作业会举手，但是你不知道是谁举手，需要一个个的去询问。
 *     解释2✔：在用户空间调用select函数后，会将四个fd拷贝一份到内核空间，由内核空间进行遍历，检查fd对应的socket是否有数据到来，
 *               遍历后返回 就绪的fd的数量（复用了fd_set，fd_set入参时表示监听的fd，回参时表示就绪的fd）。
 *               返回后用户空间知道有数据就绪，但并不知道是哪一个fd上的socket就绪，所以用户空间上也需要进行遍历
 *  优点：将socket是否就绪检查逻辑下沉到操作系统层面，避免大量系统调用。由于不需要每个 FD 都进行一次系统调用，解决了频繁的用户态内核态切换问题
 *  缺点：
 *   单进程（每个进程）监听的 FD 存在限制（由于底层使用数组存储），默认1024
 *   每次调用需要将 FD 从用户态拷贝到内核态
 *   不知道具体是哪个文件描述符就绪，需要遍历全部文件描述符
 *   入参的 3个 fd_set 集合每次调用都需要重置
 *
 *（4） IO多路复用模型poll:
 *     解释：Poll 跟 select 基本一样，主要优化了监听1024的限制。主要就是通过数据结构的优化，底层使用链表存储数据，打破了1024的限制，此外，利用两个不同的参数来存储监听事件和就绪事件，所以无需每次都重置fd_set。
 *  优点：将socket是否就绪检查逻辑下沉到操作系统层面，避免大量系统调用。由于不需要每个 FD 都进行一次系统调用，解决了频繁的用户态内核态切换问题
 *  缺点：
 *   每次调用需要将 FD 从用户态拷贝到内核态
 *   不知道具体是哪个文件描述符就绪，需要遍历全部文件描述符
 *
 * （5）IO多路复用模型epoll:
 *  问题：select/poll中，每次调用还需要将fd全部复制一份到内核空间中，如果fd比较大，这也是一个比较大的开销，此外，在返回就绪事件时，select/poll是无法知道具体是哪个fd就绪的，这就需要再次进行遍历，这也是一个比较大的开销
 *     解释1：学生写完了作业会举手，你知道是谁举手，你直接去收作业。
 *     解释2✔：epoll实际上是将文件描述符直接维护在内核态中（使用红黑树），由此解决了select/poll中，每次调用还需要将fd全部复制一份到内核空间中。
 *               此外，通过就绪列表，可以知道哪些文件描述符是就绪的，用户空间无需再次进行遍历。
 *  缺点：
 *   跨平台性不够好，只支持 linux，macOS 等操作系统不支持
 *   相较于 epoll，select 更轻量可移植性更强
 *   在监听连接数和事件较少的场景下，select 可能更优
 *
 @author Alex
 @create 2023-06-18-13:02
 */
public class UC00 {
}
