package useDDL01;

/**
 * 【约束constraint】
 *  数据完整性（Data Integrity）是指数据的精确性（Accuracy）和可靠性（Reliability）。
 *   它是防止数据库中存在不符合语义规定的数据和防止因错误信息的输入输出造成无效操作或错误信息而提出的。
 *  ✔✔约束是表级的强制规定。可以在创建表时规定约束（通过 CREATE TABLE 语句），或者在表创建之后通过ALTER TABLE语句规定约束。
 *
 * 【约束的分类】
 *  根据约束数据列的限制，约束可分为：
 *    单列约束：每个约束只约束一列
 *    多列约束：每个约束可约束多列数据
 *  根据约束的定义位置（或是作用范围），约束可分为：
 *    列级约束：只能作用在一个列上，声明在列的定义后面
 *    表级约束：可以作用在多个列上，不与列一起，在表中的所有字段声名完，声明在所有字段后面
 *  根据约束起的作用，约束可分为：
 *    NOT NULL 非空约束，规定某个字段不能为空
 *    UNIQUE 唯一约束，规定某个字段在整个表中是唯一的
 *    PRIMARY KEY 主键(非空且唯一)约束
 *    FOREIGN KEY 外键约束
 *    CHECK 检查约束。MySQL5.7不支持check约束
 *    DEFAULT 默认值约束
 *
 * 【通用约束常见命令】
 *  SELECT * FROM information_schema.table_constraints     # 查看某个表的已有的约束
 *   WHERE table_name = '表名称';
 *  create table 表名称(
 *     字段名 数据类型 UNIQUE,                            # 列级约束指定方式一,单列约束
 *     字段名 数据类型,
 *     字段名 数据类型,
 *     [constraint 约束名] UNIQUE(字段名)                # 表级约束指定方式一，单/多列约束。可以直接UNIQUE(字段名)，不为约束起名
 *   );
 *  alter table 表名称 modify 字段名 数据类型 NOT NULL;           # 列级约束指定方式二，单列约束
 *  alter table 表名称 ADD [constraint 约束名] UNIQUE(字段名);    # 表级约束指定方式二，多列约束
 *
 * 【NOT NULL】
 *  非空约束属于列级约束✔，只能出现在表对象的列上
 *  默认，所有的类型的值都可以是NULL，注意 空字符串''不等于NULL，0也不等于NULL
 *  alter table 表名称 modify 字段名 数据类型 NULL;      # 删除约束的两种方式
 *   alter table 表名称 modify 字段名 数据类型;
 *
 * 【UNIQUE】
 * （1）添加UNIQUE
 *  既是表级约束，也是列级约束✔
 *  在创建唯一约束的时候，如果不给唯一约束命名，就默认和列名相同。
 *  唯一性约束允许列值为空。且可以多次添加null
 *  MySQL会给添加唯一性约束的列上默认创建一个唯一索引。可以通过  show index from 表名称; 查看表的索引
 *  ✔复合唯一约束：当字段列表中写的是多个字段名（多列约束），多个字段名用逗号分隔，表示那么是复合唯一，即多个字段的组合是唯一即为合法
 * (2)删除UNIQUE
 *  删除唯一约束只能通过删除唯一索引的方式删除。
 *  删除时需要指定唯一索引名，唯一索引名就和唯一约束名相同!
 *  如果创建唯一约束时未指定名称，如果是单列，就默认和列名相同；如果是多列，那么默认和()中排在第一个的列名相同。也可以自定义唯一性约束名。
 *  ALTER TABLE 表名 DROP INDEX 唯一索引名（唯一约束名）;
 *
 *【PRIMARY KEY】用来唯一标识表中的一行记录。
 *  ✔主键约束既是列级约束，也是表级约束。一个表最多只能有一个主键约束。
 *  主键约束相当于唯一约束+非空约束的组合，主键约束列不允许重复，也不允许出现空值。。。。相当于弥补了唯一标识中能重复添加空值的问题，真正实现了唯一性
 *  MySQL的主键名总是PRIMARY，就算自己命名了主键约束名也没用。
 *  复合主键：当主键约束对应着表中多列时，称为复合主键约束，组合的值不允许重复。并且这些列都不允许为空值
 *  当创建主键约束时，系统默认会在所在的列或列组合上建立对应的主键索引（使用主键查询与其他查询方式效率更高）。如果删除主键约束了，主键约束对应的索引就自动删除了。
 *  不要修改主键字段的值。因为主键是数据记录的唯一标识，如果修改了主键的值，就有可能会破坏数据的完整性。
 *  ALTER TABLE 表名称 DROP PRIMARY KEY;                # 删除主键的方式，在实际开发中不会删除主键约束的
 *
 * 【AUTO_INCREMENT】
 *  通常为主键列添加自增长列约束✔，也可以为唯一键列添加自增长
 *  一个表最多只能有一个自增长列
 *  当需要产生唯一标识符或顺序值时，可设置自增长
 *  自增约束的列的数据类型必须是整数类型
 *  理论上使用了自增列，不需要为自增列赋值了。
 *   但如果为自增列指定了0和null，会在当前最大值的基础上自增；
 *   如果自增列手动指定了具体值，直接赋值为具体值。下次为自增列添加数据时，从该具体开始自增
 *  ALTER TABLE 表名称 MODIFY 字段名 数据类型;        # 删除AUTO_INCREMENT，不指定即删除，同NOT NULL
 *
 * 【MySQL 8.0新特性—自增变量的持久化】
 *  理论上使用了自增列，不需要为自增列赋值了。在MySQL 5.7系统中自增主键放在内存中维护。当数据库重启时，该计数器会被初始化。
 *    如：自增列ID为1 2 3 4 5，当删除了4 5列后，继续添加数据为 1 2 3 6。当我们重启了数据库，添加数据时会重置为1 2 3 4
 *  MySQL 8.0将自增主键的计数器持久化到重做日志中。每次计数器发生改变，都会将其写入重做日志中。
 *   如果数据库重启，InnoDB会根据重做日志中的信息来初始化计数器的内存值。所以，我们无论是否重启，添加数据都为 1 2 3 6
 *
 * 【FOREIGN KEY】限定某个表的某个字段的引用完整性。如员工表中的部门ID必须能在departments中找到，即设置departments为主表，employees为从表, employees的 department_id引用departments中的department_id
 * （1）创建外键约束
 *  ✔外键属于表级约束！只能使用表级约束声明
 *  创建(CREATE)表时就指定外键约束的话，先创建主表，再创建从表。在“从表”中指定外键约束，并且一个表可以建立多个外键约束
 *     create table 从表名称(
 *        字段名 数据类型,
 *        字段名 数据类型,
 *        字段名 数据类型,
 *        [CONSTRAINT 约束名] FOREIGN KEY (从表的字段) REFERENCES 主表名(被引用字段)
 *      );
 *     ALTER TABLE 从表名 ADD [CONSTRAINT 约束名] FOREIGN KEY (从表的字段) REFERENCES 主表名(被引用字段)
 *  从表的外键列，必须引用/参考主表的主键或唯一约束的列
 *  在创建外键约束时，如果不给外键约束命名，默认名不是列名，而是自动产生一个外键名（例如student_ibfk_1;）。也可以指定外键约束名。
 *  指定了外键约束的列，只能输入来自主表中的数据（来自外键约束REFERENCE的字段）
 *  删表时，先删从表（或先删除外键约束），再删除主表
 *  从表的外键列与主表被参照的列名字可以不相同，但是数据类型必须一样，逻辑意义一致。
 *  当创建外键约束时，系统默认会在所在的列上建立对应的普通索引。但是索引名是列名，不是外键的约束名。（根据外键查询效率很高）
 *  删除外键约束后，必须 手动 删除对应的索引
 * （2）约束等级
 *  Cascade方式 ：在父表上update/delete记录时，同步update/delete掉子表的匹配记录
 *  Set null方式 ：在父表上update/delete记录时，将子表上匹配记录的列设为null，但是要注意子表的外键列不能为not null
 *  No action/Restrict方式 ：默认方式✔。如果子表中有匹配的记录，则不允许对父表对应候选键进行update/delete操作
 *  方式 ：同no action
 *  Set default方式 （在可视化工具SQLyog中可能显示空白）：不常用。父表有变更时，子表将外键列设置成一个默认的值，但Innodb不能识别
 *     create table 从表名称(
 *        字段名 数据类型,
 *        字段名 数据类型,
 *        字段名 数据类型,
 *        [CONSTRAINT 约束名] FOREIGN KEY (从表的字段) REFERENCES 主表名(被引用字段) on update cascade on delete set null     # 把修改操作设置为级联修改等级，把删除操作设置为set null等级
 *      );                                                                                                                # 即当修改主表中的数据，从表自动变更，删除主表中的数据，从表自动set null
 *  推荐使用ON UPDATE CASCADE ON DELETE RESTRICT
 *（3）删除外键约束
 *  ALTER TABLE 从表名 DROP FOREIGN KEY 外键约束名;          # 删除外键约束
 *  SHOW INDEX FROM 表名称;                                 # 查看某个表的索引名
 *   ALTER TABLE 表名 DROP INDEX 索引名(外键约束名);                      # 删除索引名，必须手动删除
 *（4）外键的使用建议
 * 在MySQL 里，外键约束是有成本的，需要消耗系统资源。对于大并发的 SQL 操作，有可能会不适合。比如大型网站的中央数据库，
 * 可能会因为外键约束的系统开销而变得非常慢。所以，在实际开发中，我们通常不使用系统自带的外键约束，而在应用层面完成检查数据一致性的逻辑。
 *
 * 【CHECK】
 *  CHECK属于列级约束✔
 *  用于检查某个字段的值是否符号xx要求，一般指的是值的范围。在MySQL 8.0中可以使用check约束，5.7中不支持
 *  create table employee(
 *      id int primary key,
 *      name varchar(5),
 *      gender char CHECK ('男' or '女')
 * );
 *
 * 【DEFAULT约束】
 *  格式：DEFAULT 默认值
 *  属于列级约束✔
 *  给某个字段/某列指定默认值，一旦设置默认值，在插入数据时，如果此字段没有显式赋值，则赋值为默认值
 *  ALTER TABLE 表名称 MODIFY 字段名 数据类型;        # 删除DEFAULT约束，不指定即删除，同NOT NULL和AUTO_INCREMENT
 *
 @author Alex
 @create 2023-01-17-18:41
 */
public class US06 {
    /*
    面试1、为什么建表时，加 not null default '' 或 default 0
    答：不想让表中出现null值。

    面试2、为什么不想要 null 的值
    答:（1）不好比较。null是一种特殊值，比较时只能用专门的is null 和 is not null来比较。碰到运算符，通常返回null。
       （2）效率不高。影响提高索引效果。因此，我们往往在建表时 not null default '' 或 default 0

    面试3、带AUTO_INCREMENT约束的字段值是从1开始的吗？
    答: 在MySQL中，默认AUTO_INCREMENT的初始值是1，每新增一条记录，字段值自动加1。
    设置自增属性（AUTO_INCREMENT）的时候，还可以指定第一条插入记录的自增字段的值，
    这样新插入的记录的自增字段值从初始值开始递增，如在表中插入第一条记录，同时指定id值为5，
    则以后插入的记录的id值就会从6开始往上增加。添加主键约束时，往往需要设置字段自动增加属性。

    面试4、并不是每个表都可以任意选择存储引擎？
    答:外键约束（FOREIGN KEY）不能跨引擎使用。MySQL支持多种存储引擎，每一个表都可以指定一个不同的存储引擎，
    需要注意的是：外键约束是用来保证数据的参照完整性的，如果表之间需要关联外键，却指定了不同的存储引擎，那么这些表之间是不
    能创建外键约束的。所以说，存储引擎的选择也不完全是随意的。
     */
}
