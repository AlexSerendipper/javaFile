package transaction;

/**
 * 【锁分类2：根据锁粒度】
 *  为了尽可能提高数据库的并发度，每次锁定的数据范围越小越好，但是管理锁是很 耗资源 的事情。因此数据库系统需要在 高并发响应 和 系统性能 两方面进行平衡，这样就产生了“锁粒度（Lock granularity)"的概念。
 * （1）表级锁之S锁/X锁
 *  该锁会锁定整张表，并且表锁是开销最少的策略。由于表级锁一次会将整个表锁定，所以可以很好的避免死锁的问题。当然，锁的粒度大所带来最大的负面影响就是出现锁资源争用的概率也会最高，导致并发率大打折扣。
 *    SHOW OPEN TABLES WHERE In_use > 0;        # 查看各表的加锁情况
 *    lock tables t1 read                       # 为表格t1加表级别的共享锁
 *    lock tables t1 write                      # 为表格t1加表级别的排他锁
 *    unlock tables;                            # 为各表解锁
 ----------------------------------------------
 MyISAM引擎不支持行锁，仅支持表锁，在执行查询语句（SELECT）前，会给涉及的所有表加读锁，在执行增删改操作前，会给涉及的表加写锁。
 一般情况下，innodb存储引擎是不会为这个表添加表级别的读锁或者写锁的，InnoDB的厉害之处是实现了更细粒度的 行锁！

 锁类型               自己可读                自己可写                  自己可操作其他表                  他人可读                  他人可写
 读锁（表级）           是✔                    否✔                        否                             是✔                 否，要等待锁释放
 写锁（表级）           是✔                    是✔                        否                             否，等✔             否，等
 ----------------------------------------------
 * （1）表级锁之意向锁
 *  现在有两个事务，分别是T1和T2，其中T2试图在该表级别上应用共享或排它锁，如果没有意向锁存在，那么T2就需要去检查各个页或行是否存在锁；
 *   ✔意向锁： 当我们给某些数据加上了 S/X锁，数据库会自动给更大一级的空间，比如数据页或数据表自动加上 对应的意向锁（意向S锁/意向X锁）
 *     告诉其他人这个数据页或数据表已经有人上过排它锁了，这样当其他人想要获取数据表排它锁的时候，只需要了解是否有人已经获取了这个数据表的意向排它锁即可。
 *  特点：
 *   意向锁的存在是为了协调行锁和表锁的关系（为了避免一条条检测是否加锁，生成一个对应的表锁），支持多粒度（表锁与行锁）的锁并存。
 *   意向锁是一种不与行级锁冲突的表级锁，这一点非常重要。
 *   意向锁表明了某个事务正在某些行持有了锁
 *    SELECT ... FOR SHARE;                     # 对读取的记录加S锁, innodb自动添加了表级的IS锁（意向S锁）
 *    SELECT ... FOR UPDATE;                    # 对读取的记录加X锁，innodb自动添加了表级的IX锁（意向X锁）
 *  工作：
 *   现在有两个事务，分别是T1和T2，T1在事务中为表中的一条数据加上了X锁（自动生成意向排他锁），T2试图在该表级别上加上共享或排它锁，由于与意向排他锁互斥，故被阻塞等待
 *   但是如果有两个事务，分别是T1和T2，T1在事务中为表中的一条数据加上了X锁（自动生成意向排他锁），T2在事务中为表中的另一条数据加上了X锁（自动生成意向排他锁），这是可以的，因为意向锁之间都是兼容的
 *    意向锁之间（IX 与 IS）都是互相兼容的
 *    意向排他锁IX 与 表级别的 S锁、X锁均互斥
 *    意向共享锁IS 与 表级别的 S锁兼容，与X锁互斥
 *    意向锁 与 行级别的 S锁、X锁均兼容（因为意向锁属于表级锁）
 *
 * （1）表级锁之自增锁（AUTO-INC锁）：了解
 *  AUTO-INT锁是当向使用含有AUTO_INCREMENT列的表中插入数据时需要获取的一种特殊的表级锁，在执行插入语句时就在表级别加一个AUTO-INT锁，
 *   然后为每条待插入记录的AUTO_INCREMENT修饰的列分配递增的值，在该语句执行结束后，再把AUTO-INT锁释放掉。一个事务在持有AUTO-INC锁的过程中，
 *   其他事务的插入语句都要被阻塞，可以保证一个语句中分配的递增值是连续的。也正因为此，其并发性显然并不高，
 *   当我们向一个有AUTO_INCREMENT关键字的主键插入值的时候，每条语句都要对这个表锁进行竞争
 *
 * （1）表级锁之元数据锁（MDL锁）：了解
 *  我们通常说的MyISAM引擎仅仅支持表锁，innodb引擎支持行锁 指的都是，表级的S锁/X锁
 *   但是innobd引擎也是支持表锁的，就比如MDL锁
 *  MDL 的作用是，保证读写的正确性。如，现在有两个事务，分别是T1和T2，T1在事务中遍历查询表中的数据，执行期间T2对这个表结构做变更，增加了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。
 *   因此，当对一个表做增删改查操作的时候，加MDL读锁； 当要对表做结构变更操作的时候，加MDL写锁。
 *   元数据锁 不需要显式使用，在访问一个表的时候会被自动加上。
 *
 * （2）页级锁：一般不使用页锁，了解有这个东西即可
 *  页锁的开销介于表锁和行锁之间，会出现死锁。锁定粒度介于表锁和行锁之间，并发度一般。
 *  每个层级的锁数量是有限制的，因为锁会占用内存空间，锁空间的大小是有限的。当某个层级的锁数量超过了这个层级的阈值时，就会进行锁升级。锁升级就是用更大粒度的锁替代多个更小粒度的锁，比如InnoDB 中行锁升级为表锁，这样做的好处是占用的锁空间降低了，但同时数据的并发度也下降了。
 *
 * （3）行级锁之记录锁（Record Locks）
 *  行锁（Row Lock）也称为记录锁，顾名思义，就是锁住某一行（某条记录row）。需要注意的是，MySQL服务器层并没有实现行锁机制，行级锁只在存储引擎层实现。
 *   优点：锁定力度小，发生锁冲突概率低，可实现的并发度高
 *   缺点：对于锁的开销比较大，加锁会比较慢，容易出现死锁情况
 *  InnoDB与MyISAM的最大不同有两点：一是支持事务；二是采用了行级锁。
 *  ✔记录锁也就是仅仅把一条记录锁上
 *    SELECT ... FOR SHARE;                      # innodb对读取的记录加S锁（记录锁）, mysql 8.0新增语法
 *    SELECT ... FOR UPDATE;                     # innodb对读取的记录加X锁（记录锁）：
 *
 * （3）行级锁之间隙锁（Record Locks）
 *  MySQL在 REPEATABLE READ 隔离级别下是可以解决幻读问题的，解决方案有两种，可以使用MVCC方案解决，也可以采用加锁方案解决。
 *   但是在使用加锁方案解决时有个大问题，就是事务在第一次执行读取操作时，那些幻影记录尚不存在，我们无法给这些幻影记录加上记录锁。
 *   因此InnoDB提出了一种称之为Gap Locks的锁
 *  例如数据id列分别为 1 3 8 15，当我们为id为8的数据添加了gap锁，就意味着不允许别的事务在id值为(3,8)这个区间插入新记录
 *   若此时有另外一个事务再想插入一条id值为4的新记录，它定位到该条新记录的下一条记录的id值为8，而这条记录上又有一个gap锁，所以就会阻塞插入操作，直到拥有这个gap锁的事务提交。
 *    SELECT * FROM table1 where id = 5 FOR SHARE;                      # innodb对读取的记录加间隙锁（由于查询的是不存在的记录，相当于加的是间隙锁了）
 *                                                                          此时在另一个事务中想添加id值为(3,8)这个区间的数据需要等待
 *    SELECT * FROM table1 where id = 5 FOR UPDATE;                     # S型间隙锁 和 X型间隙锁，效果完全相同
 *  间隙锁是会导致死锁的，如有两个事务T1和T2, T1加上间隙锁L1（3，8)，T2加上间隙锁L2（3，8)，间隙锁之间不会冲突。
 *   T2试图插入一行 (5,"宋红康", '二班')，被T1的间隙锁挡住了(拿到了L1)，进入等待。
 *   此时T1试图插入一行 (6,"廖泽宇", '二班')，被T2的间隙锁挡住了(拿到了L2)，形成了死锁（T2要执行完成需要T1不阻塞，而T1又因为T2而必须阻塞）
 *
 * （3）行级锁之临键锁（Next-Key Locks）
 *  next-key锁的本质就是一个记录锁和一个gap锁的合体，它既能保护该条记录，又能阻止别的事务将新记录插入被保护记录前边的 间隙。
 *  innodb默认使用的就是临键锁
 *    SELECT * FROM table1 id <=8 and id > 3 for update;               # 对id=8的记录加上X锁（记录锁），对id值为(3,8)这个区间加间隙锁
 *
 * （3）行级锁之插入意向锁（Insert Intention Locks）
 *  我们说一个事务在插入一条记录时需要判断一下插入位置是不是被别的事务加了gap锁（next-key锁也包含gap锁），如果有的话，插入操作需要等待
 *   InnoDB规定事务在等待的时候也需要在内存中生成一个锁结构，表明有事务想在某个间隙中插入新记录，但是现在在等待。直到拥有gap锁的那个事务提交，拥有插入意向锁的事务继续执行。
 *   InnoDB就把这种类型的锁命名为Insert Intention Locks。插入意向锁是一种特殊的Gap锁
 *
 @author Alex
 @create 2023-05-25-13:40
 */
public class UT05 {
}
