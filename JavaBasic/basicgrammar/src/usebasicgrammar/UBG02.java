package usebasicgrammar;

import org.junit.Test;

/**
 【运算符】

 【数值运算符】除加减乘除外
  %        ：取模（取余）。余数的符号与被取余的数相同，-12 % 5 = -2
  b = ++a  :先自增，（即a值先改变），再运算（如加减乘除、赋值、判断等）✔自增不会改变变量本身的数据类型✔✔
  b = a++  :先赋值给b，再自增
  b = --a
  b = a--
  +=；-+；/=；%= ：该赋值方式不会改变变量本身的数据类型✔

 【关系运算符】
 ><==        : 比较运算符结果都为boolean
 instanceof  : 判断是否属于某类的实例

 【逻辑运算符】
 & | !       ：与或非
 &&          ：短路与，和与判断结果完全相同✔，第一个条件判断失败时，不会执行第二个条件的数值运算，如if(false && num1++)，num1不会自增✔
 | |         ：短路或，和或判断结果完全相同✔，第一个条件判断失败时，不会执行第二个条件的数值运算，如if(true || num1++)，num1不会自增✔
 ^           ：异或，两者相同为false，不同为true

 【位运算符】**符号左右操作的都是整数则为位运算符，特点就是高效罢了
 <<        ：左移运算符，在一定范围内，在二进制上进行操作如 0001 0101左移两位0101 0100（补零），从数值上看，左移n位相当于原来的数乘2^n✔
 >>        ：右移运算符，在一定范围内，在二进制上进行操作如 1001 0101左移两位111001 01（根据补码的内涵，原来是1补1，原来0补0），从数值上看，左移n位相当于原来的数除2^n
 >>>       ：无符号右移运算符，在二进制上进行操作如 1001 0101左移两位001001 01（均补0）
 &         ：与运算，在二进制上把0看作true，1看作false， 0001 & 0101 = 0101
 |         ：或运算，  0001 & 0101 = 0001
 ^         ：异或运算，  0001 & 0101 = 1011。。。两次异或复原，1011 & 0101 = 0001
 !         ：取反运算，在二进制上全部取反

 【三元运算符】
 (条件表达式)？表达式1：表达式2  ：✔表达式为真，则执行表达式1
 1）三元表达式要求输出结果为同一类型
 2）三元表达式是可以嵌套的
 3）三元表达式一定可以改写为if else语句
 @author Alex
 @create 2023-01-09-14:09
 */
public class UBG02 {
    // 数值运算符
    @Test
    public void test() {
        int n = 10;
        n += (n++) + (++n);  // 即 n = n + (n++) + (++n)
        System.out.println(n); // 10 + 10 + 12  （n++处为10，但是n经过此运算变为11，故++n处为12）
    }

    // 逻辑运算符
    @Test
    public void test2() {
        int x = 1, y = 1;
        if (x++ == 1 || ++y == 1) {
            x = 7;
        }
        System.out.println("x=" + x + ",y=" + y);
    }

    @Test
    public void test3() {
        boolean x = true;
        boolean y = false;
        short z = 42;
        if ((z++ == 42) && (y = true)) z++;  // z = 44,注意这里y是赋值操作，不是判断，我也是醉了
        if ((x = false) || (++z == 45)) z++;
        System.out.println(z);
    }

}
