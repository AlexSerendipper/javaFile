package transaction;

/**
 * 【锁分类3：根据对待锁的态度】
 *  从对待锁的态度来看锁的话，可以将锁分成乐观锁和悲观锁，从名字中也可以看出这两种锁是两种看待数据并发的思维方式。
 *   ✔需要注意的是，乐观锁和悲观锁并不是锁，而是锁的设计思想。
 *（1）悲观锁（Pessimistic Locking）
 *   悲观锁总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。
 *   比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁，当其他线程想要访问数据时，都需要阻塞挂起。
 *   Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。
 *    select .... for update                     # 是MySQL中悲观锁
 *  ✔✔注意：select ... for update语句执行过程中所有扫描的行都会被锁上，因此在MySQL中用悲观锁必须确定使用了索引，而不是全表扫描，否则将会把整个表锁住。
 *  悲观锁存在一些不足，因为悲观锁大多数情况下依靠锁机制实现，以保证程序的并发性，同时这样对数据库性能开销影响也很大，这时就需要乐观锁。
 *
 *（2）乐观锁
 *  乐观锁认为对同一数据的并发操作不会总发生，属于小概率事件，不用每次都对数据上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，
 *   也就是不采用数据库自身的锁机制，而是通过程序来实现。在程序上，我们可以采用版本号机制或者CAS机制实现。
 *   ✔乐观锁适用于多读的应用类型，这样可以提高吞吐量。
 *   在Java中java.util.concurrent.atomic包下的原子变量类就是使用了乐观锁的一种实现方式：CAS实现的。
 *  乐观锁的版本号机制
 *   在表中设计一个版本字段 version，第一次读的时候，会获取 version 字段的取值。对数据进行更新或删除操作时，会执行UPDATE ... SET version=version+1 WHERE version=version。
 *   此时如果已经有事务对这条数据进行了更改，修改就不会成功。
 *   这种方式类似我们熟悉的SVN、CVS版本管理系统，当我们修改了代码进行提交时，首先会检查当前版本号与服务器上的版本号是否一致，如果一致就可以直接提交，如果不一致就需要更新服务器上的最新代码，然后再进行提交。
 *  乐观锁的时间戳机制
 *   时间戳和版本号机制一样，也是在更新提交的时候，将当前数据的时间戳和更新之前取得的时间戳进行比较，如果两者一致则更新成功，否则就是版本冲突。
 *   乐观锁本质上就是程序员自己控制数据并发操作的权限，基本是通过给数据行增加一个戳（版本号或者时间戳），从而证明当前拿到的数据是否最新。
 *  乐观锁和悲观锁的适用场景✔
 *   乐观锁适合读操作多的场景，相对来说写的操作比较少。它的优点在于程序实现，不存在死锁问题，不过适用场景也会相对乐观，因为它阻止不了除了程序以外的数据库操作。
 *   悲观锁适合写操作多的场景，因为写的操作具有排它性。采用悲观锁的方式，可以在数据库层面阻止其他事务对该数据的操作权限，防止 读 - 写 和 写 - 写 的冲突。
 *
 * 【锁分类4：根据加锁的方式】
 * （1）隐式锁：DML操作中，删改操作 自动加X锁，增操作 自动加隐式锁
 *  特殊情况：一个事务在执行 INSERT 操作时，如果即将插入的 间隙 已经被其他事务加了 gap间隙锁，那么本次INSERT操作就会阻塞，并且当前事务会在该间隙上加一个插入意向锁
 *   而在正常情况时：INSERT操作是不加锁的。那如果一个事务首先插入了一条记录，然后另一个事务读取了这条记录，就会产生脏读的问题，如果另一个事务修改了这条记录，就会产生脏写的问题
 *   innodb使用隐式锁来解决这个问题
 *  工作流程：对于聚簇索引记录来说，有一个trx_id隐藏列，该隐藏列记录着最后改动该记录的事务id。那么如果在当前事务中新插入一条聚簇索引记录后，
 *    该记录的trx_id隐藏列代表的的就是当前事务的事务id，如果其他事务此时想对该记录添加S锁或者X锁时，首先会看一下该记录的trx_id隐藏列代表的事务是否是当前的活跃事务，
 *    如果是的话，那么就帮助当前事务创建一个X锁（也就是为当前事务创建一个锁结构，is_waiting属性是false），然后自己进入等待状态（也就是为自己也创建一个锁结构，is_waiting属性是true）
 *  隐式锁其实是一种延迟加锁的机制
 *   一个事务对新插入的记录可以不显示的加锁（生成一个锁结构），但是由于事务id的存在，相当于加了一个隐式锁。
 *   若有别的事务在对这条记录加S锁或者X锁时，由于隐式锁的存在，会先帮助当前事务生成一个锁结构，然后自己再生成一个锁结构后进入等待状态，从而来减少加锁的数量。
 *   隐式锁在实际内存对象中并不含有这个锁信息。只有当产生锁等待时,隐式锁转化为显式锁。
 * （2）显式锁
 *  显式锁：通过特定的语句进行加锁，我们一般称之为显示加锁。
 *    SELECT ... FOR SHARE;                     # 显示加共享锁
 *    SELECT ... FOR UPDATE;                    # 显示加排他锁
 *
 * 【锁分类5：其他锁】
 * （1）全局锁
 *  全局锁就是对整个数据库实例加锁。当你需要让整个库处于只读状态的时候，可以使用这个命令。
 *   使用该命令后，其他线程的DML、DDL等所有操作都会被阻塞
 *   全局锁的典型使用场景是：做全库逻辑备份。
 *    Flush tables with read lock
 * （2）死锁
 *  死锁：两个事务都持有对方需要的锁，并且在等待对方释放，并且双方都不会释放自己的锁的情况
 * （3）如何处理死锁
 * 方式1：等待，直到超时（innodb_lock_wait_timeout=50s）
 *       即当两个事务互相等待时，当一个事务等待时间超过设置的阈值时，就将其回滚，另外事务继续进行。这种方法简单有效，在innodb中，参数innodb_lock_wait_timeout 用来设置超时时间。
 * 缺点:对于在线服务来说，这个等待时间往往是无法接受的。
 * 方式2：使用死锁检测进行死锁处理
 *       方式1检测死锁太过被动，innodb还提供了 wait-for graph 算法来主动进行死锁检测，每当加锁请求无法立即满足需要并进入等待时，wait-for graph算法都会被触发。
 *       算法一旦检测到有死锁，这时候InnoDB存储引擎会选择 回滚undo量最小的事务，让其他事务继续执行(innodb_deadlock_detect=on 表示开启这个逻辑)。
 *       这是一种较为 主动的死锁检测机制 ，要求数据库保存锁的信息链表 和 事务等待链表 两部分信息。
 * 缺点：每个新的被阻塞的线程，都要判断是不是由于自己的加入导致了死锁，这个操作时间复杂度是O(n)。如果100个并发线程同时更新同一行，意味着要检测100*100= 1万次，1万个线程就会有1千万次检测。
 *（4）如何避免死锁：了解即可
 *  合理设计索引，使业务SQL尽可能通过索引定位更少的行，减少锁竞争。
 *  调整业务逻辑SQL执行顺序，避免update/delete长时间持有锁的SQL在事务前面。
 *  避免大事务，尽量将大事务拆成多个小事务来处理，小事务缩短锁定资源的时间，发生锁冲突的几率也更小。
 *  在并发比较高的系统中，不要显式加锁，特别是是在事务里显式加锁。如select ... for update语句，如果是在事务里运行了start transaction或设置了autocommit等于0，那么就会锁定所查找到的记录。
 *  降低隔离级别。如果业务允许，将隔离级别调低也是较好的选择，比如将隔离级别从RR调整为RC，可以避免掉很多因为gap锁造成的死锁。
 @author Alex
 @create 2023-05-25-13:40
 */
public class UT06 {
}
