package mysqlstructure;

/**
 * 【MySQL逻辑架构】
 *  MySQL是典型的C/S架构，服务端使用的是mysql。不论客户端进程和服务器进程采用哪种方式进行通信，最终的效果都是：客户端进程向
 *   服务器进程（mysql）发送一段SQL语句，服务器进程处理后向客户端进程返回一段文本（处理结果）
 *  以查询请求为例，✔MySQL逻辑架构图见Xmind分为：连接管理、解析与优化、存储引擎三部分
 *    连接层：connection pool
 *    服务层：SQL interface、Parser、Optimizer、Caches&Buffers
 *    引擎层：Pluggable Storage Engines
 *
 * 【SQL执行流程】以SQL服务器角度分析，见MySQL逻辑架构图序号
 *（1）查询缓存：首先，客户端与MySQL服务器段建立通信后，查询缓存！
 *     Server 如果在查询缓存中发现了完全相同的SQL语句，就会直接将结果返回给客户端；如果没有，就进入到解析器阶段。
 *     ✔需要说明的是，因为查询缓存 要求两次查询的SQL语句必须是完全一样的（有空格的差距都不行），并且可能存在缓存失效的情况（已经被修改的数据，仍然能在缓存中找到），导致缓存查询命中率不高。所以在 MySQL8.0 之后就抛弃了这个功能。
 *     ✔一般建议大家在静态表（极少更新的表）中使用查询缓存
 *（2）解析器：解析器先做“ 词法分析 ”。MySQL需要识别出里面语句的字符串分别代表什么。如 "select" 代表查询语句，字符串“T”识别成“表名 T”，字符串“ID”识别成“列 ID”。
 *     接着，要做“ 语法分析 ”。根据词法分析的结果，语法分析器（比如：Bison）会根据语法规则，判断你输入的这个 SQL 语句是否 满足 MySQL 语法。如果语法也正确，则会生成一个语法树。
 *（3）优化器：在优化器中会确定 SQL 语句的执行路径（一条查询可以有多种执行方式，MySQL决定如何执行效率最高，效果最好），并生成执行计划。 比如是根据 全表检索 ，还是根据 索引检索等
 *     在查询优化器中，可以分为 逻辑查询 优化阶段和 物理查询 优化阶段。
 *     ✔逻辑查询优化就是通过SQL等价变换来提升查询效率
 *     ✔物理查询优化则是通过索引和表连接方式等技术来进行优化
 *（4）执行器：在执行之前需要判断该用户是否 具备权限 。如果没有，就会返回权限错误。如果具备权限，就根据 执行计划 调用存储引擎 执行SQL查询并返回结果。
 *      在 MySQL8.0 以下的版本，如果设置了查询缓存，这时会将查询结果进行缓存。
 *
 * 【SQL执行流程可视化分析】后边对数据库进行优化时 还会使用这种方式进行定位
 *   set profiling = 1                                # 设置记录SQL执行过程中的细节
 *   SHOW PROFILES                                    # 查看近期执行的SQL语句
 *   SHOW PROFILE FOR QUERY 4                         # 查看具体某次SQL语句的细节
 *   SHOW PROFILE cpu,block io FOR QUERY 4            # 查看具体某次SQL语句的细节, 额外查询cpu io阻塞等参数情况
 *
 *  【Oracle中SQL执行流程】了解内容，112集内容
 * 1.语法检查：检查 SQL 拼写是否正确，如果不正确，Oracle 会报语法错误。
 * 2.语义检查：检查 SQL 中的访问对象是否存在。比如我们在写 SELECT 语句的时候，列名写错了，系统就会提示错误。语法检查和语义检查的作用是保证 SQL 语句没有错误。
 * 3.权限检查：看用户是否具备访问该数据的权限
 * 4.共享池检查：共享池（Shared Pool）是一块内存池，最主要的作用是缓存 SQL 语句和该语句的执行计划。Oracle 通过检查共享池是否存在 SQL 语句的执行计划，来判断进行软解析，还是硬解析。
 *   Oracle 首先对 SQL 语句进行 Hash 运算 ，然后根据 Hash 值在库缓存（Library Cache）中查找，如果 存在 SQL 语句的执行计划 ，就直接拿来执行，直接进入“执行器”的环节，这就是 软解析 。
 *   如果没有找到 SQL 语句和执行计划，Oracle 就需要创建解析树进行解析，生成执行计划，进入“优化器”这个步骤，这就是 硬解析 。
 * 5.优化器：优化器中就是要进行硬解析，也就是决定怎么做，比如创建解析树，生成执行计划。
 * 6.执行器：当有了解析树和执行计划之后，就知道了 SQL 该怎么被执行，这样就可以在执行器中执行语句了。
 *
 *  【数据库缓冲池(buffer pool)】类似于电脑中的内存
 *  InnoDB 存储引擎是以 “页” 为单位来管理存储空间的，我们进行的增删改查操作其实本质上都是在访问“页”。而磁盘 I/O 需要消耗的时间很多，而在内存中进行操作，效率则会高很多，
 *    为了能让数据表或者索引中的数据随时被我们所用，DBMS会申请 占用内存来作为 数据缓冲池 ，在真正访问“页”之前，需要把在磁盘上的 页 缓存到内存中的 Buffer Pool 之后才可以访问。
 *  缓冲池原则：因为缓冲池的大小是有限的，比如磁盘有 200G，但是内存只有 16G，缓冲池大小只有 1G，就无法将所有数据都加载到缓冲池里，这时就涉及到优先级顺序，会 优先对使用频次高的热数据进行加载
 *  缓冲池预读特性：在内存大小允许的范围内，会将存储“页”的上下“页”存储到缓冲池当中
 * ✔✔注意：查询缓存与数据库缓冲池，完全就是两回事
 *
 * 【缓冲池的使用】
 *  缓冲池管理器会尽量将经常使用的数据保存起来，在数据库进行页面读操作的时候，首先会判断该页面是否在缓冲池中，如果存在就直接读取，如果不存在，就会通过内存或磁盘将页面存放到缓冲池中再进行读取。
 *  如果我们执行 SQL 语句的时候更新了缓存池中的数据，那这些数据会以一定的频率更新到磁盘上
 *  set global key_buffer_size = 268435456;                         # 设置MyISAM存储引擎的缓存大小（其只缓存索引）
 *  set global innodb_buffer_pool_size = 268435456;                 # 设置innodb存储引擎的缓存大小
 *  Buffer pool 本质是 InnoDB 向操作系统申请一块连续的内存空间。多线程并发情况访问，访问buffer pool中的数据都需要加锁处理，在多线程高并发的情况，单一的Buffer pool 会影响请求的处理速度。
 *   所以我们可以将其拆分成若干个小的 Buffer pool ，每个Buffer pool 都是一个实例，独立申请内存空间，独立管理数据。多线程并发访问时，不会互相影响，提高并发处理能力。
-----------------------
[server]
innodb_buffer_pool_instances = 2                      # 修改buffer pool实例的个数
-----------------------
 *
 * 【缓冲池的问题】
 * 假设我们修改Buffer Pool中的数据成功，但是还没来得及将数据刷入磁盘，MySQL就挂了。。。这样更新的数据就只存在于Buffer Pool中。。。
 * 这种时候就需要借助Redo Log & Undo Log来解决上述问题
 @author Alex
 @create 2023-05-11-15:57
 */
public class US04 {

}
