package jvm;

/**
 * 【JVM组成1】
 * 【本地方法栈 与 native关键字】
 *  native的作用
 *     示例：在new Thread().start()方法中有一个方法。private native void start0();
 *     ✔凡是带了native关键字的，说明java的作用范围达不到了，需要调用底层c语言的库！
 *       ✔具体调用方式为：进入本地方法栈，调用本地方法本地接口（JNI，即Java Native Interface）
 *  JNI作用
 *     开拓Java的使用，融合不同的编程语言为Java所用！
 *  本地方法栈的作用
 *     在内存区域中专门开辟了一块标记区域，用来登记native方法。在执行引擎最终执行时通过 JNI 加载本地方法库中的方法
 *
 * 【程序计数器】Program Counter Register
 *  每个线程都有一个程序计数器，是线程私有的，是一个非常小的内存空间，几乎可以忽略不计。
 *  作用：本质就是一个指针。 要知道 方法区中的字节码文件，里面的一行一行的都是JVM指令
 *    程序计数器的作用就是记住下一条JVM指令的执行地址（类似于记住行号一样），让执行引擎可以顺利读取下一条指令
 *  特点
 * （1）线程私有：
 *      Java程序是支持多线程运行的，多个线程运行的时候，CPU会有一个调度器组件，给他们分配时间片，比如说给线程1分配一个时间片，
 *      若在时间片内，线程1的代码没有执行完，他就会把线程1的状态执行暂存，切换到线程2去，
 *      因为不能让线程2老等着，等线程2代码执行到一定程度了，线程2的时间片用完了，那么切换回来再继续执行线程1的剩余部分的代码，这是时间片的概念。
 *      那如果在线程切换的过程中，如果我要记住下一条指令执行到哪里了，那么还是要用到程序计数器, 并且由于各自执行的指令地址都是不一样的，所以每个线程都需要自己的程序计数器。
 *      在jvm规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致✔。
 * （2）不存在内存溢出
 *      程序计数器是在Java虚拟机规范中规定的唯一一个不会存在内存溢出（OOM，OutOfMemoryError）的区。
 *      比如其他的一些区（堆、栈、方法区之类的）他们都会出现内存溢出。
 *
 * 【方法区】
 *  方法区被所有线程共享！所有定义的方法的信息都保存在该区域
 *  存放内容：
 *   ✔✔✔ 静态变量(static)、常量(final)、类信息(.Class运行时类)、常量池。四者存在于方法区中，
 *   注意：实例变量存在堆内存中，和方法区无关
 *
 * 【栈】
 *  结构：先进后出，后进先出。类似于一个桶的结构。。。。队列就是先进先出
 *  为什么main()先执行，最后结束~
 *    main的主线程开始执行，就把main方法放到栈空间中，由于在栈的最下面，所以main方法最后结束。
 *  作用：
 *   栈可以管理线程的生命周期，当main方法结束（栈空间为空时），线程就结束 即程序就结束了
 *   对于栈来说，完全不存在垃圾回收问题
 *  存放内容：
 *   ✔✔✔9大基本类型 + 对象引用 + 实例的方法
 *
 * 【classLoader、堆、栈、方法区的关系】见xmind
 * （1）classLoader将 class文件字节码 内容加载到内存中，即 将这些静态数据转换成方法区的运行时数据结构（一个代表这个类的java.lang.Class对象（运行时类对象））
 *                                                   以及 将这些静态数据转换成堆空间的实例数据（对象具体的实例）
 *                                                   并且把堆中的 实例链接到方法区的运行时数据结构上
 * （2）栈空间只存放 堆空间的实例对象的引用
 * （3）堆空间中的常量，引用方法区中的常量池
 *
 @author Alex
 @create 2023-06-04-15:26
 */
public class UJ02 {
}
