package basicfunction;

/**
 * 【redis缓存异常】
 *  存在以下异常情况，（1）缓存与数据库的数据不一致（2）缓存雪崩（3）缓存击穿（4）缓存穿透
 *
 * 【缓存与数据库的数据不一致】
 *  一般我们在更新数据库数据时，需要同步redis中缓存的数据，所以存在两种方法：第一种方案：先执行update操作，再执行缓存清除。 第二种方案：先执行缓存清除，再执行update操作。这两种方案的弊端是当存在并发请求时，很容易出现以下问题：
 *   第一种方案：当请求1执行update操作后，还未来得及进行缓存清除，此时请求2查询到并使用了redis中的旧数据。
 *   第二种方案：当请求1执行清除缓存后，还未进行update操作，此时请求2进行查询到了旧数据并写入了redis。
 *  ✔mysql 和 redis 数据一致性是一个复杂的课题，通常是多种策略同时使用，例如：延迟双删、redis 过期淘汰、通过路由策略串行处理同类型数据、分布式锁等等。
 * （1）延时双删
 *  延迟双删策略是分布式系统中数据库存储和缓存数据保持一致性的常用策略，但它不是强一致
 *  工作流程：
 * 1. 服务节点删除 redis 主库数据。（一删）
 * 2. 服务节点修改 mysql 主库数据。
 * 3. 服务节点使得当前业务处理 等待一段时间，等 redis 和 mysql 主从节点数据同步成功。
 * 4. 服务节点从 redis 主库删除数据。（二删）
 * 5. 当前或其它服务节点读取 redis 从库数据，发现 redis 从库没有数据，从 mysql 从库读取数据，并写入 redis 主库。
 *  设置延迟时间，是因为 mysql 和 redis 主从节点数据同步不是实时的，所以需要等待一段时间，去增强它们的数据一致性。
 * （2）redis 过期淘汰
 *  所以 redis 的定位是缓存热点数据，热点数据应该设置过期时间，当数据过期后，redis 会自动淘汰，
 *   这样当业务服务节点从 redis 查询已淘汰的数据时，查询不到数据，会重新从 mysql 数据库读取数据写入 redis。
 *   这也是加强 redis / mysql 数据一致性的相对简单有效的方法。
 * （3）路由策略串行处理同类型数据
 *  很多时候，数据不一致是因为多个节点并行读写共享数据导致。如果某些特定业务只落在某个进程某个线程上独立 串行 处理，也能够在一定程度上增强 数据一致性。
 *
 * 【缓存雪崩】
 *  缓存雪崩是指缓存同一时间大面积的失效，导致大量的请求落到数据库上，造成数据库短时间内承受大量请求而崩掉。这就是缓存雪崩。
 *  解决方案：
 * 1. 缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。
 * 2. 一般并发量不是特别多的时候，使用最多的解决方案是加锁排队。
 * 3. 给每一个缓存数据增加相应的缓存标记，记录缓存的是否失效，如果缓存标记失效，则更新数据缓存。
 *
 * 【缓存击穿】
 *  缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。和缓存雪崩不同的是，缓存雪崩是大规模的key失效，而缓存击穿是某个热点的key失效，
 *  解决方案:
 * 1. 设置热点数据永远不过期。永不过期实际包含两层意思:
 *    - 物理不过期，针对热点key不设置过期时间
 *    - 逻辑过期，把过期时间存在key对应的value里， 如果发现要过期了，通过一个后台的异步线程进行缓存的构建
 * 2. 加互斥锁，互斥锁。比如某个key只允许一个线程查询数据和写缓存，其他线程等待。这种方式会阻塞其他的线程，此时系统的吞吐量会下降
 * 3. 缓存预热。缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题
 *    - 数据量不大的时候，工程启动的时候进行加载缓存动作；
 *    - 数据量大的时候，设置一个定时任务脚本，进行缓存的刷新；
 *    - 数据量太大的时候，优先保证热点数据进行提前加载到缓存。
 * 4. 缓存降级。缓存降级是指缓存失效或缓存服务器挂掉的情况下，不去访问数据库，直接返回默认数据或访问服务的内存数据。降级一般是有损的操作，所以尽量减少降级对于业务的影响程度。在进行降级之前要对系统进行梳理，看看系统是不是可以丢卒保帅；从而梳理出哪些必须誓死保护，哪些可降级；比如可以参考日志级别设置预案：
 *    - 一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；
 *    - 警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；
 *    - 错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；
 *    - 严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。
 *
 * 【缓存穿透】
 *  缓存穿透是指 缓存和数据库中都没有的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。即 用户每次请求该数据都要去数据库中查询一遍。如果有恶意攻击者不断请求系统中不存在的数据，会导致短时间大量请求落在数据库上，造成数据库压力过大，甚至导致数据库承受不住而宕机崩溃。
 *  解决方法
 * 1. 接口层增加校验，如用户鉴权校验，id做基础校验，id<=0的直接拦截；
 * 2. 将无效的key存放进Redis中:
 * 当出现Redis查不到数据，数据库也查不到数据的情况，我们就把这个key保存到Redis中，设置value="null"，并设置其过期时间极短，后面再出现查询这个key的请求的时候，直接返回null，就不需要再查询数据库了，样可以防止攻击用户反复用同一个id暴力攻击。但这种处理方式是有问题的，假如传进来的这个不存在的Key值每次都是随机的，那存进Redis也没有意义。
 * 3. 使用布隆过滤器:
 *    - 采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力。（布隆过滤器判定某个key不存在布隆过滤器中，那么就一定不存在， 如果判定某个key存在，那么很大可能是存在，但也存在一定的误判率）。
 *    - 于是我们可以在缓存之前再加一个布隆过滤器，将数据库中的所有key都存储在布隆过滤器中，在查询Redis前先去布隆过滤器查询key是否存在
 *
 @author Alex
 @create 2023-07-13-17:54
 */
public class UBF19 {
}
