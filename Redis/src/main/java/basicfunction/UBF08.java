package basicfunction;

/**
 * 【redis事务】
 *  可以一次执行多个命令（一组命令的集合）。在一个事务中的所有命令都会序列化，
 *   将所有命令放在队列中 按顺序地串行化执行，而不会被其他命令插入
 *
 * 【事务常用命令】
 *  MULTI                # 事务开始
 *  EXEC    　　　　　　 # 执行事务
 *  DISCARD              # 放弃事务
 *  WATCH key            # 监视一个（或多个）key
 *  UNWATCH              # 取消WATCH命令对所有key的监视
 *
 * 【常见情况】
 * （1）全部失败
 *  MULTI
 *    set k1 v1
 *    set k2 v2
 *    set k3              # 当出现了语法错误，整个事务中的命令将都不起作用
 *  EXEC
 * （2）部分失败
 *  MULTI
 *    set k1 v11
 *    set k2 v22
 *    INCR email          # 当出现运行时异常，整个事务中只有这条命令不起作用
 *  EXEC
 * （3）WATCH监控
 *  悲观锁：认为每次去拿数据都很认为别人会修改，所以每次拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁
 *  乐观锁（默认使用）：认为每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据。提交版本必须 大于 记录当前版本才能执行更新
 *  一旦执行了EXEC，之前加的所有监控锁都会被取消！
 *   一旦客户端连接丢失，所有监控锁也会被全部取消
---------------------------------------------
        ① WATCH balance                   ② set balance 200   # 在开启事务MULTI前，在另一个服务中修改balance，此时执行EXEC（全部失败：整个事务操作都不会执行）, 会返回nil值（默认乐观锁操作）
          MULTI
            set balance 100
          EXEC
---------------------------------------------
 * （4）UNWATCH监控
 ---------------------------------------------
        ① WATCH balance                   ② set balance 200   # 在开启事务MULTI前，在另一个服务中修改balance
          UNWATCH                                             # UNWATCH操作就相当于WATCH的逆操作，即不对balance进行监控，此时执行EXEC，会顺利执行！
          MULTI
             set balance 100
          EXEC
 ---------------------------------------------
 * 【redis事务 vs 传统的数据库事务】
 * （1）redis命令执行是单线程架构，在执行完事务内所有指令前，不可能去同时执行其他客户端的请求
 * （2）redis事务没有隔离级别的概念
 * （3）redis事务不能保证原子性，也就是不能保证所有的指令他同时成功或同时失败（没有执行到一半回滚的能力）
 * （4）redis事务能保证一个事务内的命令依次执行，而不被其他命令插入
 *
 @author Alex
 @create 2023-03-30-20:56
 */
public class UBF08 {

}
