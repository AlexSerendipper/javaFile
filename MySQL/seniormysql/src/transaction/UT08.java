package transaction;

/**
 * 【MVCC简介】Multiversion Concurrency Control，多版本并发控制
 *  在我们平常使用数据库的时候，一般不会关注MVCC，我们通常关注的是隔离级别。MVCC实际上是在隔离级别的下层，✔即我们是如何在各种隔离级别下实现并发
 *  MVCC是通过数据行的多个版本管理来实现数据库的并发控制。这项技术使得在InnoDB的事务隔离级别下执行一致性读（快照读）操作有了保证。
 *   简言之，就是可以 查询到一些正在被另一个事务更新的行，并且可以看到它们被更新之前的值，这样在做查询的时候就不用等待另一个事务释放锁。
 *  MVCC 没有正式的标准，在不同的DBMS中MCC的实现方式可能是不同的，也不是普遍使用的，这里讲解InnoDB中MVCC的实现机制（MySQL其它的存储引擎并不支持它)。
 *
 * 【快照读与当前读】
 *  MVCC在MySQL InnoDB中的实现主要是为了提高数据库并发性能，用更好的方式去处理读-写冲突，做到即使有读写冲突时，也能做到不加锁，非阻塞并发读，
 *   而这个读指的就是快照读, 而非当前读。。。当前读实际上是一种加锁的操作，是悲观锁的实现。而MVCC本质是采用乐观锁思想的一种方式。
 *  快照读（一致性读）：读取的是快照数据。不加锁的简单的 SELECT 都属于快照读，即不加锁的非阻塞读。比如这样：
 *    SELECT * FROM player WHERE ...
 *   快照读的出现 是基于提高并发性能的考虑，快照读的实现是基于MVCC，即快照读可能读到的并不一定是数据的最新版本，但它在很多情况下，避免了加锁操作，降低了开销。
 *  当前读：读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，即会对读取的记录进行加锁。  加锁的 SELECT，或者对数据进行增删改都会进行当前读。
 *
 * 【Readview简介】
 *  COMPACT行格式中，对于记录的真实数据里，除了真实列还存储了三个隐藏列 DB_ROW_ID， DB_TRX_ID， DB_ROW_PTR。
 *   DB_TRX_ID：每次一个事务对某条聚簇索引记录进行改动时，都会把该事务的事务id赋值给 trx_id 隐藏列。
 *   DB_ROW_PTR：每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到 undo日志中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。
 *  在MVCC机制中，多个事务对同一个行记录进行更新会产生多个历史快照，这些历史快照保存在Undo Log里。
 *   如果一个事务想要查询这个行记录，需要读取哪个版本的行记录呢?这时就需要用到ReadView了
 *   ReadView就是事务在使用MVCC机制进行快照读操作时产生的读视图
 *  ✔ MVCC 的实现依赖于：隐藏字段(trx_id、roll_pointer)、Undo Log、ReadView 。
 *  ✔ MVCC只能在READ COMMTTED和REPEATABLE READ两个隔离级别下工作
 *       MVCC主要解决 READ COMMITTED和REPEATABLE READ 隔离级别下的事务并发问题，即假如另一个事务已经修改了记录但是尚未提交，我们不能直接读取最新版本的记录，
 *       ReadView 要解决的主要问题核心问题是 需要判断一下版本链中的哪个版本是当前事务可见的
 *  Readview中主要包含四个核心内容：
 *    creator_trx_id                 # 创建这个Read View 的事务 ID。
 *                                      (只有在对表中的记录做改动时（增删改时）才会为事务分配事务id，读 事务中的事务id值都默认为0）
 *    trx_ids                        # 表示在生成ReadView时当前系统中 活跃的读写事务（启动了，但还未提交） 的事务id列表
 *    up_limit_id                    # 活跃的事务中最小的事务 ID。
 *    low_limit_id                   # 表示生成ReadView时系统中应该分配给下一个事务的id值。low_limit_id 是系统最大的事务id值，这里要注意是系统中的事务id，需要区别于正在活跃的事务ID。
 *
 * 【ReadView的规则】MVCC实现原理
 *  如果被访问版本的 trx_id属性值 与ReadView中的creator_trx_id值相同，意味着当前事务 在访问它自己修改过的记录，所以该版本可以被当前事务访问。
 *  如果被访问版本的 trx_id属性值 小于ReadView中的up_limit_id值，表明生成该版本的事务在当前事务生成ReadView前已经提交，所以该版本可以被当前事务访问。
 *  如果被访问版本的 trx_id属性值 大于或等于ReadView中的low_limit_id值，表明生成该版本的事务在当前事务生成ReadView后才开启，所以该版本不可以被当前事务访问。
 *  如果被访问版本的 trx_id属性值 在ReadView的up_limit_id和low_limit_id之间，那就需要判断一下trx_id属性值是不是在 trx_ids 列表中。
 *   如果在，说明创建ReadView时生成该版本的事务还是活跃的，该版本不可以被访问。
 *   如果不在，说明创建ReadView时生成该版本的事务已经被提交，该版本可以被访问。
 *  我们来看下当查询一条记录的时候，系统如何通过MVCC找到它：
 *   （1）首先获取事务自己的版本号，也就是事务 ID；
 *   （2）获取 ReadView；
 *   （3）查询得到的数据，然后与 ReadView 中的事务版本号进行比较；
 *   （4）如果不符合 ReadView 规则，就需要从 Undo Log 中获取历史快照；最后返回符合规则的数据。
 *   （5）如果某个版本的数据对当前事务不可见的话，那就顺着版本链找到下一个版本的数据，继续按照上边的步骤判断可见性，依此类推，直到版本链中的最后一个版本。如果最后一个版本也不可见的话，那么就意味着该条记录对该事务完全不可见，查询结果就不包含该记录
 *  ✔ 在隔离级别为 读已提交（Read Committed）时，一个事务中的每一次 SELECT 查询都会重新获取一次ReadView。
 *  ✔ 当隔离级别为可重复读的时候，就避免了不可重复读，这是因为 一个事务中 只在第一次 SELECT 的时候会获取一次 Read View，而后面所有的 SELECT 都会复用这个 Read View
 *
 * 【innodb解决幻读】
 *  MySQL的可重复读隔离级别，不存在幻读问题。
--------------------
假设现在有事务 A 和事务 B 并发执行，事务 A的事务 id 为20，事务 B的事务 id 为30。
 select * from student where id >= 1;                     # 事务A执行查询语句
在开始查询之前，MySQL 会为事务 A 产生一个 ReadView，此时 ReadView 的内容如下：trx_ids= [20,30]，up_limit_id=20，low_limit_id=31，creator_trx_id=20。
接着事务 B(trx_id=30)，往表 student 中新插入两条数据，并提交事务。
接着事务 A 开启第二次查询，根据可重复读隔离级别的规则，此时事务 A 并不会再重新生成ReadView。此时表 student 中的 3 条数据都满足 where id>=1 的条件，因此会先查出来。
然后根据ReadView 机制，新插入的数据它的 trx_id=30，此时事务 A 发现，这个值处于 up_limit_id 和 low_limit_id 之间，并且30 处于 trx_ids 数组内，因此在数组内，所以这条数据不能让事务 A 看到。
--------------------
 *
 * 【MVCC的优势】
 *  读写之间阻塞的问题。通过MVCC可以让读写互相不阻塞，即读不阻塞写，写不阻塞读，这样就可以提升事务并发处理能力。
 *  降低了死锁的概率。这是因为MVCC采用了乐观锁的方式，读取数据时并不需要加锁，对于写操作，也只锁定必要的行。
 *  解决快照读的问题。当我们查询数据库在某个时间点的快照时，只能看到这个时间点之前事务提交更新的结果，而不能看到这个时间点之后事务提交的更新结果。
 *
 @author Alex
 @create 2023-05-27-8:52
 */
public class UT08 {
}
