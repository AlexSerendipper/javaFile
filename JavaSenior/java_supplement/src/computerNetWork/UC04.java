package computerNetWork;

/**
 * 【TCP】
 *  TCP的通信是基于连接的，可以分为三个步骤
 * （1）三次握手
 *      当客户端向服务端发起请求时，会先发一包连接请求数据（SYN数据包），询问能否建立连接
 *      如果服务端同意建立连接，则回复一个SYN+ACK包
 *      客户端收到后，回复一个ACK包，则连接建立
 *        因为这个过程中发送了三次数据，所以称之为三次握手。
 * （2）传输确认（确认应答原理）：解决丢包、乱序问题
 *      经过三次握手后，客户端和服务端都进入了数据传输状态。。。一个数据包可能被拆成多个，并且数据包到达的先后顺序可能不同，如何解决数据包的丢包、乱序问题呢
 *       为了解决上述问题，tcp协议为每一个连接建立了发送缓冲区，发送缓冲区的第一个字节的序列号为0，后面每个字节号都会增加1
 *       （首先将数据写入发送缓冲区）
 *       发送数据时，从发送缓冲区取一部分数据（序列号+长度）组成发送报文，在其tcp协议头中会附带序列号和长度，————"这个发送报文最终就由：序列号、长度、数据内容组成！！"
 *       接收端在收到数据后，需要回复确认报文，确认报文中的ACK包含了 序列号加长度，这个 序列号+长度 是下一包数据发送的起始序列号和长度！！
 *       这样一问一答的方式能够使得发送端确认发送的数据已经被对方收到，发送端也可以一次性发送连续的多包数据，接收端只需要回复一次ACK就可以了，
 *       这样发送端可以把待发送的数据分割成一系列的碎片发送到对端，对端根据序列和长度在接收后重构出来完整的数据，
 *       假设其中丢失了某些数据包，在接收端可以要求发送端重传。比如丢失100-199这100个字节，接收端向发送端发送ACK=100的报文，发送端收到后重传这包数据，接收端进行补齐！！
 *       这种方式不论在客户端还是服务端均适用！
 * （3）四次挥手
 *  处于连接状态的客户端和服务端，都可以发起关闭连接请求，此时需要四次挥手来进行连接关闭
 *   假设客户端主动发起连接关闭请求，需要向服务端发起一包FIN包，表示关闭连接，自己进入终止等待1状态，这是第一次挥手
 *   服务端随后发送一包ACK包，表示自己进入了关闭等待状态，客户端进入终止等待2状态，这是第二次挥手，
 *   服务端此时还可以发送未发送的数据，客户端还可以接收数据，
 *   待服务端发送完数据后，发送一个FIN包进入最后确认状态，这是第三次挥手，
 *   客户端收到回复ACK包，进入超时等待状态，经过超时时间后关闭连接，服务端收到ack包后立即关闭连接，这是第四次挥手。
 *  客户端需要等待超时时间的原因是，需要保证对方已经收到ACK包，假设客服端发送完最后一包ACK就释放了连接，一旦ACK包在网络中丢失，服务端将一直停留在最后确认状态，
 *   如果客户端发送最后一包ACK包后，进入停留等待，这时候服务端会因为没收到ACK包会重发FIN包，客户端会响应这个FIN包，重发ACK包并刷新超时时间。
 *   这个功能和三次握手一样，也是为了在不可靠的网络链路中，进行可靠的连接断开
 *
 * 【TCP是如何保证可靠性的？】
 * （1）校验和机制
 *      计算发送端 数据的校验和，如果接收端算出来的检验和和发送端发送的不一样，那么接收端认为报文在传输过程中出了错，就会丢弃该数据。
 * （2）确认应答和序列号机制
 *      即上述的 传输确认 过程
 * （3）超时重传机制
 *     指发送出去数据包后，一段时间后没有收到服务端发来的 收到数据的回应报文，则认为数据发送失败，会重新发送一次数据包
 * （4）连接管理
 *     在进行连接时以及断开连接时，有三次握手和四次挥手来保证有效连接
 * （5）流量控制
 *     根据接收端的能力，抑制发送方发送数据的速率，使得接收方来得及接受。
 * （6）拥塞控制
 *     会向探路一样，先发送小的数据，防止堵塞
 *
 * 【TCP的粘包和拆包问题】应用层进行处理
 *  为什么TCP有粘包和拆包问题 而 UDP没有呢？
 *    因为，UDP提供了数据边界。而TCP基于流协议（面向流），传输的是一串没有边界的数据
 *  在应用层判定，一个完整的包要进行拆分/合并处理
 *    粘包：两个数据包被合并起来。一起发送给服务器端
 *    拆包：将一个数据包拆分为一个或多个数据包，发送给服务器端
 *  为什么会发生拆包和粘包
 *    要发送的数据小于TCP发送缓冲区的大小，TCP将多次写入缓冲区的数据一次发送出去，将会发生粘包；
 *    接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包；
 *    要发送的数据大于TCP发送缓冲区剩余空间大小，将会发生拆包；
 *  解决方法：
 *   （1）发送端将每个数据包封装为固定长度（不足的字节补0或1）
 *   （2）在数据尾部增加特殊字符进行分割
 *   （3）将数据分为两部分，一部分是头部，一部分是内容体；其中头部结构大小固定，且有一个字段声明内容体的大小。
 *
 * 【SYN FLOOD】泛洪攻击
 *  该攻击是利用TCP握手过程缺陷，发送大量连接请求，导致服务器半连接队列溢出 或 服务器资源耗尽，最终导致服务器无法处理正常请求
 *    该攻击本质上和三次握手密切相关，与服务器的两个队列SYN QUEUE半连接队列 和 ACCEPT QUEUE全连接队列
 *      SYN QUEUE半连接队列：进入半连接队列意味着服务器已经接收到了SYN，并且已经发送了SYN+ACK
 *      ACCEPT QUEUE全连接队列：当服务器收到了客服端回复的ACK后，会进入全连接队列
 *      SYN攻击者会在短时间内伪造大量不存在的IP地址，向服务器不断地发送syn包，这些伪造的SYN包将长时间占用未连接队列，
 *     半连接队列/全连接队列 是有上限的，如果请求连接数量过多，导致队列溢出，则会丢弃数据包（即导致新连接被丢弃，导致拒绝服务）！
 *  解决：
 *   通过防火墙、路由器等过滤网关防护；
 *   通过加固TCP/IP协议栈防范，比如增加最大半连接数，缩短超时时间。
 *   使用SYN cookies技术，这个技术是对服务器端的三次握手做一些修改，是用来专门SYN防范洪范攻击的一种手段。
 *
 * 【为什么不是两次握手?】
 *  为什么不在服务端发完SYN+ACK完就建立连接？？
 *   这是为了防止已失效的请求报文，突然又传到服务器引起错误。
 *   假设两次握手建立连接，客户端向服务端发送了一个SYN包来请求建立连接，因为某些未知的原因并未到达服务器，在中间某个网络节点产生了滞留，为了建立连接客户端会重发SYN包，这次数据包正常送达，服务端回答SYN+ACK，建立连接。
 *   但是第一包数据阻塞的网络节点突然恢复，第一包SYN包又送到服务端，这时服务端会误认为客户端又发起了一个新的连接，从而两次握手之后进入等待数据状态。服务端认为两个连接，客户端认为是一个连接，造成了状态不一致。
 *   三次握手的话接收不到最后的ACK包（因为当前客户端有连接，不会再传一个ACK包过去），就认为连接失败，所以三次握手就是为了解决网络信道不可靠的问题！！TCP协议就是实现了在不可靠的信道上实现了可靠的连接
 *
 * 【UDP】
 *  UDP的通信是基于非连接的
 *   发送数据时，就只是把数据简单的封装一下，然后从网卡发出去，数据包之间并没有状态上的联系
 *   正因为UDP这种简单的处理方式，导致它的性能损耗非常小（对于CPU和内存的占用远小于TCP），
 *   但是对于网络传输中的丢包等问题，UDP协议并无法保证，所以它的传输稳定性要小于TCP
 *  TCP和UDP的区别
 *    TCP是基于连接的; UDP是基于非连接的（发送数据之前不需要建立连接）
 *    TCP传输数据稳定可靠，适用于对网络通信质量较高的场景，如：传输文件、发送邮件、浏览网页等。
 *      UDP不保证可靠交付，但是它的速度快，适用于对实时性要求较高，但是对少量丢包没有太大要求的场景，如：语音通话、视频直播等。
 *    TCP对每一条连接 是点到点的; UDP支持 一对一、一对多、多对一和多对多的通信方式。

 @author Alex
 @create 2023-06-17-14:33
 */
public class UC04 {
}
