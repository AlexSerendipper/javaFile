package index;

/**
 * 【MySQL数据结构选择】
 *  为什么我们使用b+tree，而不是其他数据结构呢。
 *   查找都是索引的操作，一般来说索引非常大，尤其是关系型数据库，当数据量比较大的时候，索引的大小有可能几个G甚至更多，为了减少索引在内存的占用，数据库索引是存储在外部磁盘上的。
 *   ✔✔当我们利用索引查询的时候，不可能把整个索引全部加载到内存，只能逐一加载，那么MySQL衡量查询效率的标准就是磁盘IO次数。
 *   接下来介绍各种数据结构~ 以及为什么最终选择使用b+tree
 *  加速查找速度的数据结构，常见的有两类：
 *     树： 例如平衡二叉搜索树，查询/插入/修改/删除的平均时间复杂度都是O(log2N)
 *     哈希：例如HashMap，查询/插入/修改/删除的平均时间复杂度都是O(1)；
 *
 *（1）全表加载
 *     按照索引一条条加载
 *
 *（2）Hash结构
 *  Hash本身是一个函数，又被称为散列函数，它可以帮助我们大幅体会是能检索数据的效率。Hash算法是通过某种确定的算法(比如MD5、SHA1、SHA2、SHA3) 将输入转变为输出。
 *   相同的输入永远可以得到相同的输出，假设输入内容有微小偏差，输出都会不同。
 *   举例：如果你想要验证两个文件是否相同，那么你不需要把两份文件直接拿来比对，只需要让对方把Hash函数计算得到的结果告诉你即可
 *  在使用Hash结构存储时，若发生数据的碰撞，即两个不同的数据映射的相同的位置（Hash算法一般不会得到相同的输出，但我们在映射时，比如将数据映射到16个槽位，很有可能发生碰撞）
 *   在数据库中一般都是使用链式法来解决该类问题
 *  ✔Hash结构效率高，那为什么索引结构要设计成树形呢？
 *    原因1：Hash索引仅满足（=)（!=）和IN查询。如果进行范围查询，哈希型的索引，时间复杂度会退化为O(n); 而树形的“有序”特性，依然能够保持O(log2N)的高效率。
 *    原因2：Hash索引还有一个缺陷，数据的存储是没有顺序的，在ORDER BY的情况下，使用Hash索引还需要对数据重新排序。
 *    原因3: 对于联合索引的情况，Hash值是将联合索引合并后一起来计算的，无法对单独的一个键或者几个索引健进行查询。
 *    原因4：对于等值查询来说，通常Hash索引的效率更高，不过也存在一种情况，就是索引列的重复值如果很多，效率就会降低。这是因为遇到Hash冲突（碰撞）时，需要遍历桶中的行指针来进行比较，找到查询的关键字，非常耗时。
 *  仅Memory引擎支持Hash索引（默认索引），MyISAM 与 InnoDB 不支持Hash索引
 *  Hash索引 适用于：
 *    在键值型（Key-Value）数据库中，Redis存储的核心就是Hash表。
 *    MySQL中Memory存储引擎支持Hash索引，如果我们需要用到查询的临时表是，就可以选择Memory存储引擎，把某个字段设置为Hash索引。
 *    ✔InnoDB本身不支持Hash索引，但是提供自适应Hash索引（Adaptive Hash Index)。如果某个数据经常被访问，当满足一定条件的时候，就会将这个数据页的地址存放到Hash表中。
 *      这样下次查询的时候，就可以直接找到这个页面的所在位置。这样让B+树也具备了Hash索引的优点。见xmind
 *
 *（3）二叉搜索树
 *  特点：一个节点（父节点）只能有两个子节点，左子节点 < 父节点; 右子节点 >= 父节点
 *  但是存在特殊的情况，比如数据是（5,22,23,34,77,89,91），这时候二叉树的深度非常大，性能上已经退化成了一条链表，查找数据的时间复杂度变成了0(n)
 *   为了提高查询效率，就需要减少磁盘IO数。为了减少磁盘IO的次数，就需要尽量降低树的高度！~
 *
 *（4）AVL树（平衡二叉搜索树）
 *  特点：为了解决上面二叉查找树退化成链表的问题，增加了如下约束。 ① 要么它是一棵空树 ，② 要么它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。
 *  针对同样的数据，如果我们把二叉树存储为 M叉树（M > 2），就可以进一步降低树的高度，实现把树从“瘦高”变成“矮胖”
 *
 *（5）B树：Balance Tree，就是多路平衡查找树。
 *  B树作为多路平衡查找树，它的每一个节点最多可以包含M个子节点，M称为B树的阶。每个磁盘块中包括了关键字和子节点的指针。对于大量的索引数据来说，采用B树的结构是非常合适的，因为树的高度远小于二叉树的高度。
 *   见xmind中，假设我们想要查找的关键字是9，查找步骤为：与根节点的关键字（17,35）进行比较，9小于17那么得到指针P1; 按照指针P1找到磁盘块2，关键字为（8,12）,因为9在8和12之间，所以我们得到指针P2;按照指针P2找到磁盘块6，关键字为（9,10），然后我们找到了关键字9
 *  特点：
 *    B树在插入和删除节点的时候如果导致树不平衡，会通过自动调整节点的位置来保持树的自平衡。
 *    ✔关键字集合分布在整棵树中，即叶子节点和非叶子节点都存放数据。搜索有可能在非叶子节点结束。
 *    其搜索性能等价于在关键字全集内做一次二分查找。
 *
 *（6）B+Tree：同样也是多路平衡查找树，是在B树的基础上做了一些改进。相比于B-Tree，B+Tree适合文件索引系统。
 *  B+树和B树的差异
 *    B+树中有k个关键字（数据页中的记录的key）就有k个孩子节点（数据页的数量），也就是关键字数 = 孩子数量 ，而B树中，关键字数 + 1 = 孩子数量。
 *    ✔B+树非叶子节点的关键字 也会同时存在在子节点的关键字中
 *      ✔这就意味着 B+树的非叶子节点仅用于索引，不保存数据记录，跟记录有关的信息都放在叶子节点中。
 *      也意味着 B+树中 所有关键字（key）都在叶子节点出现，叶子节点构成一个有序链表，而且叶子节点本身按照关键字的大小从小到大顺序链接。
 *      而B树中，非叶子节点既保存索引，也保存数据记录。
 *  为什么说 B+树是B树的提升？
 *    首先，B+树查询效率更稳定。因为B+树每次只有访问到叶子节点才能找到对应的数据，而在B树中，非叶子节点也会存储数据，有时候访问到了非叶子节点就可以找到关键字，
 *    其次，B+树的查询效率更高。这是因为通常B+树比B树更矮胖（阶树更大，深度更低），查询所需要的磁盘I/O也会更少。
 *    在查找范围上，B+树的效率也比B树高。这是因为所有关键字都出现在B+树的叶子节点中，叶子节点之间会有指针，数据又是递增的，这使得我们范围查找可以通过指针连接查找。而在B树种则需要通过中序遍历才能完成查找范围的查找，效率要低很多。
 *
 *（7）R树：了解
 *  R-Tree在MySQL很少使用，仅支持geometry数据类型,支持该类型的存储引擎只有MyISM、bdb、InnoDB、ndb、archive几种。
 *   R树就很好的解决了这种高纬空间搜索问题。它把B树的思想很好的拓展到了多维空间，采用了B树分割空间的思想，并在添加、删除操作时采用合并、分解节点的方法，保证树的平衡性。因此，R树就是一棵用来存储高维数据的平衡树。
 @author Alex
 @create 2023-05-16-13:51
 */
public class UI04 {
}
