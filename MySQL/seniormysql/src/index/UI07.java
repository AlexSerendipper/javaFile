package index;

/**
 * 【页的上层结构】了解
 *  在数据库中还存在着区、段、和表空间的概念。从小到大的包含关系依次为：行——页——区——段——表。
 *   页的上层结构是区，一个区会分配64个连续页，区的大小正好是1MB(16kb * 64)。
 *   段由一个区或多个区组成。段是数据库的分配单位，比如我们创建一个表，就会创建一个表段，创建一个索引，就会创建一个索引段。总而言之，不同类型的数据库对象对应不同类型的段。
 *   表空间(table space)是一个逻辑容器。表空间中存储的是一个或者多个段，每个段只能属于一个表空间。表空间又可以分为系统表空间,用户表空间，撤销表空间、临时表空间等。
 *  为什么要有区？
 *   页与页是通过双向链表进行连接的，如果以页为单位分配存储空间，逻辑上相邻的两个页在物理磁盘上实际距离比较远。
 *   在进行范围查询时，如果页与页之间的距离过远，在进行磁盘I/O操作时加载页就需要花许多时间(寻道、旋转等)，就是随机I/O。
 *   磁盘随机I/O会花大量时间在数据页的查找加载上，非常慢。出于性能考虑，我们希望能够在相邻的位置存取数据，以便能够顺序读取数据页。
 *   当然，我们也不能够让所有数据都存储到连续的空间，毕竟越大的连续空间在磁盘上越难找到。因此我们引入了区的概念。
 *   一个区就是64个在物理空间上连续的页。因此一个区的大小是16KB * 64 = 1MB。在表的数据量大的时候，我们就不再以页为单位进行存储空间的分配了，而是连续分配一个区，甚至是多个区。
 *  为什么要有段
 *   一个区中存放的页可能是数据页或者目录页，但当我们进行范围查询时，感兴趣的只有普通数据页。
 *   如果因为存放了目录页的原因，导致范围查找的效果大打折扣（因为存放了目录页，导致数据也存储到下一个区当中）。我们希望一个区存储数据页就存储数据页，存储目录页就只存储目录页，因此出现了段的概念。
 *   常见的段有数据段、索引段、回滚段。段是逻辑上的概念。由若干零散的页(碎片区中的页，下一节介绍)和完整的区所组成。
 *  为什么要有碎片区
 *   InnoDB存储引擎一个聚簇索引会生成两个段，数据段（叶子节点）和索引段（非叶子节点），而每个段是以区作为单位申请存储空间的，如果表的数据量只有几条，也需要申请2M的空间么(一个区的大小为1M)。空间浪费严重
 *   因此提出了碎片区，在一个碎片区中，可以让多个段共用一个公共空间，一些页给段A，一些页给段B，让空间得到充分的利用！
 *   ✔所以InnoDB存储引擎分配存储空间的具体策略是：在刚向表中插入数据时，先使用碎片区以页为单位进行存储空间的分配。当某个段占用的存储空间达到了32个碎片区以后，我们再以完整的区为单位分配存储空间。
 *
 * 【区的分类】区，大体可以分成四个类型。
 *  空闲区(Free)：现在还没有用到这个区的任何页面。
 *  有剩余空间的碎片区（Free-Frag):表示碎片区中还有可用的页面。
 *  没有剩余空间的碎片区(Full-Frag)。
 *  附属于某个段的区(FSEG)：专属于给某一个段使用的完整的区。
 * ✔前三种类型的区都是独立的，直属于表空间。FSEG是属于段的。
 *
 * 【表空间】表空间是一个逻辑上的容器，是innoDB存储引擎逻辑结构的最高层，所有的数据都存放在表空间中。可以划分为：独立表空间，系统表空间，撤销表空间，临时表空间等
 * （1）独立表空间
 *  每个表对应一个表空间，也就是一个表的索引和数据会被单独保存在自己的表空间中，这样方便在不同的数据库之间进行数据的迁移。
 *   并且其空间回收也比较方便，可以通过Drop Table操作自动回收表空间。对于统计分析或者日志表，还可以在删除大量数据之后，通过alter table tableName engine=innodb回收不用的空间。这个特性使碎片空间不会太影响性能。
 *  一个新建表的.idb文件大小是96kb，也就是6个页面大小(Mysql5.7)，当然随着数据量的增加，有些idb也是自扩展的，表空间的文件大小会变大。
 * （2）系统表空间
 *  与独立表空间的结构基本类似，由于整个MySQL进程只有一个表空间，会额外记录一些关于整个系统的数据，这是独立表空间中所没有的。
 *
 @author Alex
 @create 2023-05-18-14:45
 */
public class UI07 {
}
