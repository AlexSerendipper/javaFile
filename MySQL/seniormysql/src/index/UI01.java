package index;

/**
 * 【为什么使用索引】
 *  索引是存储引擎 用于快速找到数据记录的一种数据结构，就好比一本教科书的目录部分，通过目录中找到对应文章的页码，便可快速定位到需要的文章。
 *   MySQL中也是一样的道理，进行数据查找时，首先查看查询条件是否命中某条索引，符合则通过索引查找相关数据，如果不符合则需要全表扫描,即需要一条一条地查找记录，直到找到与条件符合的记录
 *   所以，我们建索引的目的就是为了减少磁盘I/O的次数，加快查询效率
 *   注意：索引是在存储引擎中实现的，因此每种存储引擎的索引不一定完全相同
 *
 * 【索引的优缺点】
 *  优点
 *（1）提高数据检索的效率，降低数据库的IO成本,这是创建索引最主要的原因。
 *（2）通过创建唯一索引，可以保证数据库中每一行数据的唯一性。
 *（3）在实现数据的参考完整性方面，可以加速表和表之间的连接。换句话说，对于有依赖关系的子表和父表联合查询时，可以提高查询速度。
 *（4）在使用分组和排序子句进行数据查询时，可以显著减少查询中分组和排序的时间，降低了CPU的消耗。
 *  缺点
 *（1）创建索引和维护索引要耗费时间，并且随着数据量的增加，所耗费的时间也会增加。
 *（2）索引需要占磁盘空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，存储在磁盘上，如果有大量的索引，索引文件就可能比数据文件更快达到最大文件尺寸。
 *（3）虽然索引大大提高了查询速度，但却会降低更新表的速度。当对标中的数据进行增加、删除和修改的时候，索引也要动态地维护，这样就降低了数据的维护速度。
 *
 * 【InnoDB中索引的推演】
 *  数据底层使用数据页进行存储，每页存储16kb的数据
 * （1）part1
 *  在一个页中的查找：假设目前表中的记录比较少，所有的记录都可以被存放到一个页中。可以有如下两种查找方式
 *   ① 此时可以以主键为搜索条件（主键通常有序且唯一），利用二分法快速定位进行查找
 *   ② 或以其他列作为搜索条件，从最小记录开始依次遍历每条记录（效率低）
 *  若需要好多的数据页来存储记录，在很多页中查找记录的话，可以分为两个步骤；
 *   ① 定位到记录所在的页。
 *   ② 从所在的页内中查找相应的记录。
 *   由于我们并不能快速的定位到记录所在的页，所以只能从第一个页沿着双向链表一直往下找，在每一页中根据我们上面的查找方式去查找指定的记录。这种方式显然超级耗时。此时索引应运而生。
 * （2）part2：索引雏形，见xmind
 *  行格式
 *    record_type：记录头信息的一项属性，表示记录的类型，0表示普通记录、2表示最小记录、3表示最大记录、1标识目录项
 *    next_record：记录头信息的意向属性，表示下一条地址相对于本条记录的地址偏移量，我们用箭头来表明下一条记录是谁。
 *    各个列的值：这里只记录在index_demo表中的三个列，分别是c1、c2和c3。
 *    其他信息：除以上3种信息以外的所有信息，包括其他隐藏列的值以及记录的额外信息。
 *  设计要求：每一个页中的数据按照主键递增顺序存储，下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值
 *    目录项：key: 当前页的最小的主键值
 *            page_no: 当前页页号
 *  查找主键值为20的记录： 先从目录项中根据二分法快速确定为主键值为20的记录在目录项3中（因为 12 < 20 < 209），它对应的页是页9。再根据二分查找去页9中定位具体的记录。
 * （3）part3: 优化目录项1，见xmind
 *  问题：随着表中记录数量的增多，需要非常大的连续的存储空间才能把所有的目录项放下，这对记录数量非常多的表是不现实的。此外时常会对记录进行增删，
 *    假设我们把页28中的记录都删除了，那意味着目录项2也就没有存在的不要了，这就需要把目录项2后的目录项都向前移动一下，这样牵一发而动全身的操作效率低下。
 *  解决：为所有的目录项建立一个目录项记录页，
 *  区分：目录项记录页的record_type值是1，而普通用户记录页的record_type值是0。
 *         目录项记录页只有主键值和页的编号两个列，而普通的用户记录的列是用户自己定义的，可能包含很多列，另外还有InnoDB自己添加的隐藏列
 * （4）part4: 优化目录项2，见xmind
 *  虽说目录项记录页中只存储主键值和对应的页号，比用户记录需要的存储空间小多了，但是不论怎么说一个页只有16KB大小，能存放的目录项记录也是有限的，
 *   如果表中的数据太多，以至于一个数据页不足以存放所有的目录项记录的页，那就需要分配一个新的存储目录项记录的页
 *   （这里我们假设一个存储目录项记录的页最多只能存放4条目录项记录）
 * （5）part5: 优化目录项3，见xmind
 *  如果表中的数据非常多，则会产生很多目录项记录页，如何根据主键值快速定位一个存储目录项记录的页呢？
 *   那就用相同的思想，为目录项记录页再生成一个更高级的目录！
 *  查找主键值为20的记录： 先从目录项记录页目录中，根据二分法快速确定主键值为20的记录在目录项记录页30中。再根据二分查找，确定主键为20的记录在页9中。
 *  最终优化出来的这个数据结构，它的名称就是B+树！！！！！
 *
 * 【B+树】✔✔
 *  一个B+树的节点其实可以分成好多层，规定最下边的那层，也就是存放我们用户记录的那层为第0层。规定其他层，即为存放目录项记录的页（除第0层外的所有层）
 *   第0层中各叶子节点✔（第0层中，存放用户记录的数据页）使用双链连接，
 *   非叶子节点中的用户数据（存储的key，即主键或其他列 也称为关键字）使用单链连接
 *   假设所有存放用户记录的叶子节点代表的数据页可以存放100条用户记录，所有存放目录项记录页的 非叶子节点代表的数据页可以存放1000条目录项记录 ，那么：
 *   如果B+数有4层，最多能存放1000 * 1000 * 1000 * 100 = 一千亿条记录
 *   所以一般情况下，我们用到的B+树都不会超过4层，那我们通过主键值取查找某条记录最多只需要做4次IO操作（查找3个目录项页和一个用户记录页）（在目录项记录页内可以通过二分法实现快速定位记录）
 *
 @author Alex
 @create 2023-05-13-13:47
 */
public class UI01 {

}
